// @ts-nocheck
/* eslint-disable */
export const CONSTANTS = JSON.parse("{\"euler\":{\"docs\":\"The closest number to `e` (Euler's number), the base of the natural logarithms.\"},\"false\":{\"docs\":\"A value of type `bool` representing logical **false**.\"},\"null\":{\"docs\":\"No value.\\n\\n`null` represents the absence of a value.\\n\\n```scarpet\\nfoo = null;\\n```\\n\\nAny variable which is not yet defined will default to `null` (if strict mode is\\nnot set).\\n\\n```scarpet\\nprint(bar); // bar == null\\n```\\n\\nSimilarly, trying to get a non-existent key from a collection will return `null`.\"},\"pi\":{\"docs\":\"The closest number to `pi`, the ratio of the circumference of a circle to its\\ndiameter.\"},\"true\":{\"docs\":\"A value of type `bool` representing logical **true**.\"}}");
export const FUNCTIONS = JSON.parse("{\"break\":{\"signatures\":[{\"params\":[]},{\"params\":[{\"name\":\"value\"}]}],\"docs\":\"Exit early from a loop.\\n\\n`break()` terminates the execution of the current loop.\\n\\n```scarpet\\nfor([1, 2, 3], if(_ == 2, break()));\\n```\\n\\n# break\\ns\"},\"c_for\":{\"signatures\":[{\"params\":[{\"name\":\"init\"},{\"name\":\"condition\"},{\"name\":\"increment\"},{\"name\":\"body\"}]}],\"docs\":\"Mimics a C-Style `for` loop `for (init; condition; increment) { body }`\\n\\n```java\\nfor (int i = 0; i < 5; i += 1) {\\n    printf(\\\"%d\\\\n\\\", i);\\n}\\n```\\n\\n```scarpet\\nc_for(i = 0, i < 5, i += 1, print(i));\\n```\"},\"call\":{\"signatures\":[{\"params\":[{\"name\":\"function\"},{\"name\":\"args\",\"rest\":true}]}],\"docs\":\"Calls a function with the provided arguments.\\n\\nFunction values cannot be called directly and can only be executed with\\n`call()`.\\n\\n```scarpet\\nf = (_(x) -> x + 1);\\nval = call(f, 12);\\nval == 13\\n```\\n\\n`call()` can also invoke functions by name.\\n\\n```scarpet\\nf(x) -> x + 1;\\nval = call('f', 12);\\n```\\n\\n`call()` resolves function names from the call site.\"},\"continue\":{\"signatures\":[{\"params\":[]},{\"params\":[{\"name\":\"value\"}]}],\"docs\":\"Skip to the next iteration of the loop.\\n\\n`continue()` terminates execution of the current iteration skipping to the next.\\n\\n```scarpet\\nfor([1, 2, 3, 4],\\n    if(_ == 3, continue());\\n    print(_); // 1, 2, 4\\n);\\n```\"},\"for\":{\"signatures\":[{\"params\":[{\"name\":\"iterable\"},{\"name\":\"body\",\"binds\":[\"_\",\"_i\"]}],\"returns\":\"number\"}],\"docs\":\"Iterate over each item in an iterable value.\\n\\n`for()` takes two arguments, an iterable value such as a `list` or a `map`\\n(iterates over the keys of the map), and an expression to evaluate for every\\nitem. The expression receives two bound variables `_` (value) and `_i` (current\\niteration number) are supplied to the expression.\\n\\n```scarpet\\nfor([1, 2, 3, 4, 5], print(_));\\n```\\n\\n`for()` returns the number of times the expression evaluated to a successful\\nvalue.\\n\\nLike other looping functions `for()` supports `break()` and `continue()`. An\\noptional argument can be passed to `break()` or `continue()` to determine if the\\niteration was successful.\\n\\n```scarpet\\ni = for([42, 12, 56, 29], print(_i)); // 0, 1, 2, 3\\ni; // 4\\n```\"},\"if\":{\"signatures\":[{\"params\":[{\"name\":\"condition\"},{\"name\":\"if_true\"}]},{\"params\":[{\"name\":\"condition\"},{\"name\":\"if_true\"},{\"name\":\"if_false\"}]},{\"params\":[{\"name\":\"condition\"},{\"name\":\"if_true\"},{\"rest\":true}]}],\"docs\":\"Evaluate an expression if a condition holds.\\n\\n```scarpet\\nif(1 == 2, print('oops, maths broke'));\\n```\\n\\n`if()` can also be used as an expression. An extra argument can be specified to\\nact as an `else` block.\\n\\n```scarpet\\nmessage = if(player()~'gamemode' == 'creative',\\n    'Hi cheater',\\n    'Hello friend',\\n);\\n```\\n\\nUnlike most programming languages there is no `else if`. More conditions and\\nexpression can be added as arguments to the `if()` call.\\n\\n```scarpet\\nif(gamemode == 'creative',\\n    'player is in creative',\\n    gamemode == 'survival',\\n    'player is in survival',\\n    'player is not in creative or survival',\\n);\\n```\"},\"outer\":{\"signatures\":[{\"params\":[{\"name\":\"variable\",\"type\":\"variable\"}]}],\"docs\":\"Captures a variable from the outer scope.\\n\\n```scarpet\\nx = 2;\\nf(outer(x)) -> x += 1;\\nf();\\nx == 3\\n```\\n\\n`outer()` can only exist inside a function signature and only takes a single\\nvariable name as a parameter.\"},\"return\":{\"signatures\":[{\"params\":[]},{\"params\":[{\"name\":\"value\"}]}],\"docs\":\"Return a value from a function.\\n\\nA `return()` marks the end of an execution path in a function:\\n\\n```scarpet\\nfoo() -> (\\n    return(2);\\n    print('x'); // not reachable\\n);\\n```\\n\\n`return()` is not needed when the returned value is the last expression in the\\nfunction:\\n\\n```scarpet\\nfoo() -> (\\n    3\\n);\\n```\\n\\nA `return()` with no arguments returns [`null`]({{ '/constants/null/' | relative_url }}).\"},\"then\":{\"signatures\":[{\"params\":[{\"name\":\"expr\",\"rest\":true}]}],\"docs\":\"Evaluate more than one expression sequentially.\\n\\n```scarpet\\nthen(expr_1, expr_2);\\n```\\n\\n```scarpet\\nexpr_1;\\nexpr_2;\\n```\"},\"throw\":{\"signatures\":[{\"params\":[]},{\"params\":[{\"name\":\"value\"}]},{\"params\":[{\"name\":\"type\"},{\"name\":\"value\"}]},{\"params\":[{\"name\":\"subtype\"},{\"name\":\"type\"},{\"name\":\"value\"}]}],\"docs\":\"Throws an exception that can be caught in a `try` block (see above). If ran without arguments, it will throw a `user_exception`\\npassing `null` as the value to the `catch_expr`. With two arguments you can mimic any other exception type thrown in scarpet.\\nWith 3 arguments, you can specify a custom exception acting as a `subtype` of a provided `type`, allowing to customize `try`\\nstatements with custom exceptions.\"},\"try\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]},{\"params\":[{\"name\":\"expr\"},{\"name\":\"catch_expr\"}]},{\"params\":[{\"name\":\"expr\"},{\"name\":\"type\"},{\"name\":\"catch_expr\"},{\"rest\":true}]}],\"docs\":\"Evaluate an expression catching any exceptions thrown.\\n\\nThe exceptions can be\\nthrown explicitly using `throw()` or internally by scarpet where code is correct but detects illegal state. The 2-argument form\\ncatches only user-thrown exceptions and one argument call `try(expr)` is equivalent to `try(expr, null)`,\\nor `try(expr, 'user_exception', null)`. If multiple `type-catch` pairs are defined, the execution terminates on the first\\napplicable type for the exception thrown. Therefore, even if the caught exception matches multiple filters, only\\nthe first matching block will be executed.\\n\\nCatch expressions are evaluated with\\n`_` set to the value associated with the exception and `_trace` set to contain details about point of error (token, and line and\\ncolumn positions), call stack and local\\nvariables at the time of failure. The `type` will catch any exception of that type and any subtype of this type.\\n\\nYou can use `try` mechanism to exit from large portion of a convoluted call stack and continue program execution, although catching\\nexceptions is typically much more expensive comparing to not throwing them.\\n\\nThe `try` function allows you to catch some scarpet exceptions for cases covering invalid data, like invalid\\nblocks, biomes, dimensions and other things, that may have been modified by datapacks, resourcepacks or other mods,\\nor when an error is outside of the programmers scope, such as problems when reading or decoding files.\\n\\nThis is the hierarchy of the exceptions that could be thrown/caught in the with the `try` function:\\n\\n- `exception`: This is the base exception. Catching `'exception'` allows to catch everything that can be caught,\\n  but like everywhere else, doing that sounds like a bad idea.\\n  - `value_exception`: This is the parent for any exception that occurs due to an\\n    incorrect argument value provided to a built-in function\\n    - `unknown_item`, `unknown_block`, `unknown_biome`, `unknown_sound`, `unknown_particle`,\\n      `unknown_poi_type`, `unknown_dimension`, `unknown_structure`, `unknown_criterion`: Specific\\n      errors thrown when a specified internal name does not exist or is invalid.\\n  - `io_exception`: This is the parent for any exception that occurs due to an error handling external data.\\n    - `nbt_error`: Incorrect input/output NBT file.\\n    - `json_error`: Incorrect input/output JSON data.\\n    - `b64_error`: Incorrect input/output b64 (base 64) string\\n  - `user_exception`: Exception thrown by default with `throw` function.\\n\\nSynopsis:\\n\\n```scarpet\\ninner_call() -> (\\n    aaa = 'booyah';\\n    try(\\n      for(range(10), item_tags('stick'+_*'k')),\\n      print(_trace), // not caught, only catching user_exceptions\\n    );\\n);\\n\\nouter_call() -> (\\n    try(\\n        inner_call(),\\n        'exception', // catching everything\\n        print(_trace),\\n    );\\n);\\n```\\n\\nProducing:\\n\\n```\\n{\\n  stack: [[<app>, inner_call, 1, 14]],\\n  locals: {_a: 0, aaa: booyah, _: 1, _y: 0, _i: 1, _x: 0, _z: 0},\\n  token: [item_tags, 5, 23]\\n}\\n```\"},\"while\":{\"signatures\":[{\"params\":[{\"name\":\"condition\"},{\"name\":\"body\",\"binds\":[\"_\"]}]},{\"params\":[{\"name\":\"condition\"},{\"name\":\"limit\",\"type\":\"number\"},{\"name\":\"body\",\"binds\":[\"_\"]}]}],\"docs\":\"Loop while a condition holds.\\n\\n`while()` evaluates an expression repeatedly while its condition evaluates to\\n`true`. The expression receives a bound variable `_` indicating the current\\niteration number.\\n\\nReturns the result of the last iteration or `null`.\\n\\n```scarpet\\ni = 0;\\nwhile(i < 5,\\n    print(_);\\n    i += 1;\\n);\\n```\\n\\n`while()` may also be called with three arguments. Where the second argument\\nspecifies an upper limit for the number of times to loop.\\n\\n```scarpet\\ni = 0;\\nwhile(i < 7, 5, // can only loop 5 times\\n    print(_);\\n    i += 1;\\n);\\n```\"},\"all\":{\"signatures\":[{\"params\":[{\"name\":\"list\"},{\"name\":\"expr\",\"binds\":[\"_\",\"_i\"]}]}],\"docs\":\"Returns `true` if all elements on the list satisfy the condition. Its roughly equivalent\\nto `all(list,expr) <=> for(list,expr)==length(list)`. `expr` also receives bound `_` and `_i` variables. `break`\\nand `continue` have no sense and cannot be used inside of `expr` body.\\n\\n```scarpet\\nall([1,2,3], check_prime(_))  => true\\nall(neighbours(x,y,z), _=='stone')  => true // if all neighbours of [x, y, z] are stone\\nmap(filter(rect(0,4,0,1000,0,1000), [x,y,z]=pos(_); all(rect(x,y,z,1,0,1),_=='bedrock') ), pos(_) )\\n  => [[-298, 4, -703], [-287, 4, -156], [-269, 4, 104], [242, 4, 250], [-159, 4, 335], [-208, 4, 416], [-510, 4, 546], [376, 4, 806]]\\n    // find all 3x3 bedrock structures in the top bedrock layer\\nmap( filter( rect(0,4,0,1000,1,1000,1000,0,1000), [x,y,z]=pos(_);\\n        all(rect(x,y,z,1,0,1),_=='bedrock') && for(rect(x,y-1,z,1,1,1,1,0,1),_=='bedrock')<8),\\n   pos(_) )  => [[343, 3, -642], [153, 3, -285], [674, 3, 167], [-710, 3, 398]]\\n    // ditto, but requiring at most 7 bedrock block in the 18 blocks below them\\n```\"},\"bool\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Returns a boolean context of the expression.\\nBool is also interpreting string values as boolean, which is different from other\\nplaces where boolean context can be used. This can be used in places where API functions return string values to\\nrepresent binary values.\\n\\n```scarpet\\nbool(pi) => true\\nbool(false) => false\\nbool('') => false\\nbool([]) => false\\nbool(['']) => true\\nbool('foo') => true\\nbool('false') => false\\nbool('nulL') => false\\nif('false',1,0) => true\\n```\"},\"convert_date\":{\"signatures\":[{\"params\":[{\"name\":\"year\"},{\"name\":\"month\"},{\"name\":\"day\"},{\"name\":\"hours\"},{\"name\":\"minutes\"},{\"name\":\"seconds\"}]},{\"params\":[{\"name\":\"date\"}]}],\"docs\":\"If called with a single argument, converts standard POSIX time to a list in the format:\\n\\n`[year, month, day, hours, mins, secs, day_of_week, day_of_year, week_of_year]`\\n\\neg: `convert_date(1592401346960) -> [2020, 6, 17, 10, 42, 26, 3, 169, 25]`\\n\\nWhere the `6` stands for June, but `17` stands for 17th, `10` stands for 10am,\\n`42` stands for 42 minutes past the hour, and `26` stands for 26 seconds past the minute,\\nand `3` stands for Wednesday, `169` is the day of year, and `25` is a week of year.\\n\\nRun `convert_date(unix_time())` to get current time as list.\\n\\nWhen called with a list, or with 3 or 6 arguments, returns standard POSIX time as a number of milliseconds since the\\nstart of the epoch (1 Jan 1970),\\nusing the time inputted into the function as opposed to the system time.\\n\\nExample editing:\\n\\n```scarpet\\ndate = convert_date(unix_time());\\n\\nmonths = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];\\n\\ndays = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun'];\\n\\nprint(\\n  str('Its %s, %d %s %d, %02d:%02d:%02d',\\n    days:(date:6-1), date:2, months:(date:1-1), date:0, date:3, date:4, date:5\\n  )\\n)\\n```\\n\\nThis will give you a date:\\n\\nIt is currently `hrs`:`mins` and `secs` seconds on the `day`th of `month`, `year`\"},\"copy\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Returns the deep copy of the expression. Can be used to copy mutable objects, like maps and lists\"},\"decode_b64\":{\"signatures\":[{\"params\":[{\"name\":\"string\"}]}],\"docs\":\"Decode a string from base 64, throwing a `b64_error` exception if it's invalid.\"},\"decode_json\":{\"signatures\":[{\"params\":[{\"name\":\"string\"}]}],\"docs\":\"Decodes a json string as a valid value or throws a `json_error` exception if it\\ndoesn't parse properly.\"},\"delete\":{\"signatures\":[{\"params\":[{\"name\":\"container\"},{\"name\":\"address\"},{\"name\":\"addresses\",\"rest\":true}]},{\"params\":[{\"name\":\"lvalue\"}]}],\"docs\":\"Removes specific entry from the container. For the lists - removes the element and shrinks it. For maps, it\\nremoves the key from the map, and for nbt - removes content from a given path.\\n\\nLike with the `get` and `has`, `delete` can accept chained addresses, as well as l-value container access, removing\\nthe value from the leaf of the path provided, so `delete(foo, a, b)` is the\\nsame as `delete(get(foo,a),b)` or `delete(foo:a:b)`\\n\\nReturns true, if container was changed, false, if it was left unchanged, and null if operation was invalid.\"},\"encode_b64\":{\"signatures\":[{\"params\":[{\"name\":\"string\"}]}],\"docs\":\"Encode a string to base 64.\"},\"encode_json\":{\"signatures\":[{\"params\":[{\"name\":\"value\"}]}],\"docs\":\"Encodes a value as a json string.\"},\"filter\":{\"signatures\":[{\"params\":[{\"name\":\"list\"},{\"name\":\"expr\",\"binds\":[\"_\",\"_i\"]}]}],\"docs\":\"filters `list` elements returning only these that return positive result of the `expr`. With `break` and `continue`\\nstatements, the supplied value can be used as a boolean check instead.\\n\\n```scarpet\\nfilter(range(100), !(_%5), _*_>1000)  => [0, 5, 10, 15, 20, 25, 30]\\nmap(filter(entity_list('*'),_=='Witch'), query(_,'pos') )  => [[1082.5, 57, 1243.5]]\\n```\"},\"first\":{\"signatures\":[{\"params\":[{\"name\":\"list\"},{\"name\":\"expr\",\"binds\":[\"_\",\"_i\"]}]}],\"docs\":\"Finds and returns the first item in the list that satisfies `expr`. It sets `_` for current element value,\\nand `_i` for index of that element. `break` can be called inside the iteration code, using its argument value\\ninstead of the current item. `continue` has no sense and cannot be called inside `first` call.\\n\\n```scarpet\\nfirst(range(1000,10000), n=_; !first( range(2, sqrt(n)+1), !(n % _) ) )  => 1009 // first prime after 1000\\n```\\n\\nNotice in the example above, that we needed to rename the outer `_` to be albe to use in in the inner `first` call\"},\"get\":{\"signatures\":[{\"params\":[{\"name\":\"container\"},{\"name\":\"address\"},{\"name\":\"addresses\",\"rest\":true}]},{\"params\":[{\"name\":\"lvalue\"}]}],\"docs\":\"Returns the value at `address` element from the `value`. For lists it indicates an index, use negative numbers to\\nreach elements from the end of the list. `get` call will always be able to find the index. In case there is few\\nitems, it will loop over\\n\\nfor maps, retrieves the value under the key specified in the `address` or null otherwise\\n\\n[Minecraft specific usecase]: In case `value` is of `nbt` type, uses address as the nbt path to query, returning null,\\nif path is not found, one value if there was one match, or list of values if result is a list. Returned elements can\\nbe of numerical type, string texts, or another compound nbt tags\\n\\nIn case to simplify the access with nested objects, you can add chain of addresses to the arguments of `get` rather\\nthan calling it multiple times. `get(get(foo,a),b)` is equivalent to `get(foo, a, b)`, or `foo:a:b`.\\n\\n```scarpet\\nget([range(10)], 5)  => 5\\nget([range(10)], -1)  => 9\\nget([range(10)], 10)  => 0\\n[range(10)]:93  => 3\\nget(player() ~ 'nbt', 'Health') => 20 // inefficient way to get player health, use player() ~ 'health' instead\\nget({ 'foo' -> 2, 'bar' -> 3, 'baz' -> 4 }, 'bar')  => 3\\n```\"},\"has\":{\"docs\":\"Similar to `get`, but returns boolean value indicating if the given index / key / path is in the container.\\nCan be used to determine if `get(...)==null` means the element doesn't exist, or the stored value for this\\naddress is `null`, and is cheaper to run than `get`.\\n\\nLike get, it can accept multiple addresses for chains in nested containers. In this case `has(foo:a:b)` is\\nequivalent to `has(get(foo,a), b)` or `has(foo, a, b)`\"},\"join\":{\"signatures\":[{\"params\":[{\"name\":\"delim\"},{\"name\":\"list\"},{\"name\":\"joindelim\"},{\"name\":\"values\"}]}],\"docs\":\"Returns a string that contains joined elements of the list, iterator, or all values,\\nconcatenated with `delim` delimiter\\n\\n```scarpet\\njoin('-',range(10))  => 0-1-2-3-4-5-6-7-8-9\\njoin('-','foo')  => foo\\njoin('-', 'foo', 'bar')  => foo-bar\\n```\"},\"keys\":{},\"length\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Returns length of the expression, the length of the string, the length of the integer part of the number,\\nor length of the list\\n\\n```scarpet\\nlength(pi) => 1\\nlength(pi*pi) => 1\\nlength(pi^pi) => 2\\nlength([]) => 0\\nlength([1,2,3]) => 3\\nlength('') => 0\\nlength('foo') => 3\\n```\"},\"lower\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"},{\"name\":\"upperexpr\"},{\"name\":\"titleexpr\"}]}],\"docs\":\"Returns lowercase, uppercase or titlecase representation of a string representation of the passed expression\\n\\n```scarpet\\nlower('aBc') => 'abc'\\nupper('aBc') => 'ABC'\\ntitle('aBc') => 'Abc'\\n```\"},\"map\":{\"signatures\":[{\"params\":[{\"name\":\"list\"},{\"name\":\"expr\",\"binds\":[\"_\",\"_i\"]}]}],\"docs\":\"Converts a `list` of values, to another list where each value is result of an expression `v = expr(_, _i)`\\nwhere `_` is passed as each element of the list, and `_i` is the index of such element. If `break` is called the\\nmap returns whatever collected thus far. If `continue` and `break` are used with supplied argument, it is used in\\nplace of the resulting map element, otherwise current element is skipped.\\n\\n```scarpet\\nmap(range(10), _*_)  => [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\\nmap(player('*'), _+' is stoopid') [gnembon is stoopid, herobrine is stoopid]\\n```\"},\"number\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Returns a numeric context of the expression. Can be used to read numbers from strings, or other types\\n\\n```scarpet\\nnumber(null) => 0\\nnumber(false) => 0\\nnumber(true) => 1\\nnumber('') => null\\nnumber('3.14') => 3.14\\nnumber([]) => 0\\nnumber(['']) => 1\\nnumber('foo') => null\\nnumber('3bar') => null\\nnumber('2')+number('2') => 4\\n```\"},\"pairs\":{},\"perlin\":{\"signatures\":[{\"params\":[{\"name\":\"x\"},{\"name\":\"perlinx\"},{\"name\":\"y\"},{\"name\":\"perlinx\"},{\"name\":\"y\"},{\"name\":\"z\"},{\"name\":\"perlinx\"},{\"name\":\"y\"},{\"name\":\"z\"},{\"name\":\"seed\"}]}],\"docs\":\"returns a noise value from `0.0` to `1.0` (roughly) for 1, 2 or 3 dimensional coordinate. The default seed it samples\\nfrom is `0`, but seed can be specified as a 4th argument as well. In case you need 1D or 2D noise values with custom\\nseed, use `null` for `y` and `z`, or `z` arguments respectively.\\n\\nPerlin noise is based on a square grid and generates rougher maps comparing to Simplex, which is creamier.\\nQuerying for lower-dimensional result, rather than affixing unused dimensions to constants has a speed benefit,\\n\\nThou shall not sample from noise changing seed frequently. Scarpet will keep track of the last 256 perlin seeds\\nused for sampling providing similar speed comparing to the default seed of `0`. In case the app engine uses more\\nthan 256 seeds at the same time, switching between them can get much more expensive.\"},\"profile_expr\":{\"signatures\":[{\"params\":[{\"name\":\"expression\"}]}],\"docs\":\"Returns number of times given expression can be run in 50ms time. Useful to profile and optimize your code.\\nNote that, even if its only a number, it WILL run these commands, so if they are destructive, you need to be careful.\"},\"put\":{\"signatures\":[{\"params\":[{\"name\":\"container\"},{\"name\":\"address\"},{\"name\":\"value\"}]},{\"params\":[{\"name\":\"container\"},{\"name\":\"address\"},{\"name\":\"value\"},{\"name\":\"mode\"}]},{\"params\":[{\"name\":\"lvalue\"},{\"name\":\"value\"}]}],\"docs\":\"<u>**Lists**</u>\\n\\nModifies the container by replacing the value under the address with the supplied `value`. For lists, a valid\\nindex is required, but can be negative as well to indicate positions from the end of the list. If `null` is\\nsupplied as the address, it always means - add to the end of the list.\\n\\nThere are three modes that lists can have items added to them:\\n\\n- `replace`(default): Replaces item under given index(address). Doesn't change the size of the array\\n  unless `null` address is used, which is an exception and then it appends to the end\\n- `insert`: Inserts given element at a specified index, shifting the rest of the array to make space for the item.\\n  Note that index of -1 points to the last element of the list, thus inserting at that position and moving the previous\\n  last element to the new last element position. To insert at the end, use `+=` operator, or `null` address in put\\n- `extend`: treats the supplied value as an iterable set of values to insert at a given index, extending the list\\n  by this amount of items. Again use `null` address/index to point to the end of the list\\n\\nDue to the extra mode parameter, there is no chaining for `put`, but you can still use l-value container access to\\nindicate container and address, so `put(foo, key, value)` is the same as `put(foo:key, value)` or `foo:key=value`\\n\\nReturns true, if container got modified, false otherwise, and null if operation was invalid.\\n\\n<u>**Maps**</u>\\n\\nFor maps there are no modes available (yet, seems there is no reason to). It replaces the value under the supplied\\nkey (address), or sets it if not currently present.\\n\\n<u>**NBT Tags**</u>\\n\\nThe address for nbt values is a valid nbt path that you would use with `/data` command, and tag is any tag that\\nwould be applicable for a given insert operation. Note that to distinguish between proper types (like integer types,\\nyou need to use command notation, i.e. regular ints is `123`, while byte size int would be `123b` and an explicit\\nstring would be `\\\"5\\\"`, so it helps that scarpet uses single quotes in his strings. Unlike for lists and maps, it\\nreturns the number of affected nodes, or 0 if none were affected.\\n\\nThere are three modes that NBT tags can have items added to them:\\n\\n- `replace`(default): Replaces item under given path(address). Removes them first if possible, and then adds given\\n  element to the supplied position. The target path can indicate compound tag keys, lists, or individual elements\\n  of the lists.\\n- `<N>`: Index for list insertions. Inserts given element at a specified index, inside a list specified with the\\n  path address. Fails if list is not specified. It behaves like `insert` mode for lists, i.e. it is not removing any\\n  of the existing elements. Use `replace` to remove and replace existing element.\\n- `merge`: assumes that both path and replacement target are of compound type (dictionaries, maps, `{}` types),\\n  and merges keys from `value` with the compound tag under the path\\n\\n```scarpet\\na = [1, 2, 3]; put(a, 1, 4); a  => [1, 4, 3]\\na = [1, 2, 3]; put(a, null, 4); a  => [1, 2, 3, 4]\\na = [1, 2, 3]; put(a, 1, 4, 'insert'); a  => [1, 4, 2, 3]\\na = [1, 2, 3]; put(a, null, [4, 5, 6], 'extend'); a  => [1, 2, 3, 4, 5, 6]\\na = [1, 2, 3]; put(a, 1, [4, 5, 6], 'extend'); a  => [1, 4, 5, 6, 2, 3]\\na = [[0,0,0],[0,0,0],[0,0,0]]; put(a:1, 1, 1); a  => [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\\na = {1,2,3,4}; put(a, 5, null); a  => {1: null, 2: null, 3: null, 4: null, 5: null}\\ntag = nbt('{}'); put(tag, 'BlockData.Properties', '[1,2,3,4]'); tag  => {BlockData:{Properties:[1,2,3,4]}}\\ntag = nbt('{a:[{lvl:3},{lvl:5},{lvl:2}]}'); put(tag, 'a[].lvl', 1); tag  => {a:[{lvl:1},{lvl:1},{lvl:1}]}\\ntag = nbt('{a:[{lvl:[1,2,3]},{lvl:[3,2,1]},{lvl:[4,5,6]}]}'); put(tag, 'a[].lvl', 1, 2); tag\\n     => {a:[{lvl:[1,2,1,3]},{lvl:[3,2,1,1]},{lvl:[4,5,1,6]}]}\\ntag = nbt('{a:[{lvl:[1,2,3]},{lvl:[3,2,1]},{lvl:[4,5,6]}]}'); put(tag, 'a[].lvl[1]', 1); tag\\n     => {a:[{lvl:[1,1,3]},{lvl:[3,1,1]},{lvl:[4,1,6]}]}\\n```\"},\"rand\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"},{\"name\":\"randexpr\"},{\"name\":\"seed\"}]}],\"docs\":\"returns a random number from `0.0` (inclusive) to `expr` (exclusive). In boolean context (in conditions,\\nboolean functions, or `bool`), returns false if the randomly selected value is less than 1. This means\\nthat `bool(rand(2))` returns true half of the time and `!rand(5)` returns true for 20% (1/5) of the time. If seed is not\\nprovided, uses a random seed that's shared across all scarpet apps.\\nIf seed is provided, each consecutive call to rand() will act like 'next' call to the\\nsame random object. Scarpet keeps track of up to 65536 custom random number generators (custom seeds, per app),\\nso if you exceed this number, your random sequences will revert to the beginning and start over.\\n\\n```scarpet\\nmap(range(10), floor(rand(10))) => [5, 8, 0, 6, 9, 3, 9, 9, 1, 8]\\nmap(range(10), bool(rand(2))) => [false, false, true, false, false, false, true, false, true, false]\\nmap(range(10), str('%.1f',rand(_))) => [0.0, 0.4, 0.6, 1.9, 2.8, 3.8, 5.3, 2.2, 1.6, 5.6]\\n```\\n\\n## `reset_seed(seed)`\\n\\nResets the sequence of the randomizer used by `rand` for this seed to its initial state. Returns a boolean value\\nindicating if the given seed has been used or not.\"},\"range\":{\"signatures\":[{\"params\":[{\"name\":\"to\"}]},{\"params\":[{\"name\":\"from\"},{\"name\":\"to\"}]},{\"params\":[{\"name\":\"from\"},{\"name\":\"to\"},{\"name\":\"step\"}]}],\"docs\":\"Creates a range of numbers from `from`, no greater/larger than `to`. The `step` parameter dictates not only the\\nincrement size, but also direction (can be negative). The returned value is not a proper list, just the iterator\\nbut if for whatever reason you need a proper list with all items evaluated, use `[range(to)]`.\\nPrimarily to be used in higher order functions\\n\\n```scarpet\\nrange(10)  => [...]\\n[range(10)]  => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\\nmap(range(10),_*_)  => [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\\nreduce(range(10),_a+_, 0)  => 45\\nrange(5,10)  => [5, 6, 7, 8, 9]\\nrange(20, 10, -2)  => [20, 18, 16, 14, 12]\\nrange(-0.3, 0.3, 0.1)  => [-0.3, -0.2, -0.1, 0, 0.1, 0.2]\\nrange(0.3, -0.3, -0.1) => [0.3, 0.2, 0.1, -0, -0.1, -0.2]\\n```\"},\"reduce\":{\"signatures\":[{\"params\":[{\"name\":\"list\"},{\"name\":\"expr\",\"binds\":[\"_a\",\"_\",\"_i\"]},{\"name\":\"initial\"}]}],\"docs\":\"Applies `expr` for each element of the list and saves the result in `_a` accumulator. Consecutive calls to `expr`\\ncan access that value to apply more values. You also need to specify the initial value to apply for the\\naccumulator. `break` can be used to terminate reduction prematurely. If a value is provided to `break` or `continue`,\\nit will be used from now on as a new value for the accumulator.\\n\\n```scarpet\\nreduce([1,2,3,4],_a+_,0)  => 10\\nreduce([1,2,3,4],_a*_,1)  => 24\\n```\"},\"replace\":{\"signatures\":[{\"params\":[{\"name\":\"string\"},{\"name\":\"regex\"},{\"name\":\"replreplace_firststring\"},{\"name\":\"regex\"},{\"name\":\"repl\"}]}],\"docs\":\"Replaces all, or first occurrence of a regular expression in the string with `repl` expression,\\nor nothing, if not specified. To use escape characters (`\\\\(`,`\\\\+`,...), metacharacters (`\\\\d`,`\\\\w`,...), or position anchors (`\\\\b`,`\\\\z`,...) in your regular expression, use two backslashes.\\n\\n```scarpet\\nreplace('abbccddebfg','b+','z')  // => azccddezfg\\nreplace('abbccddebfg','\\\\\\\\w$','z')  // => abbccddebfz\\nreplace_first('abbccddebfg','b+','z')  // => azccddebfg\\n```\"},\"replace_first\":{},\"reset_seed\":{\"signatures\":[{\"params\":[{\"name\":\"seed\"}]}],\"docs\":\"Resets the sequence of the randomizer used by `rand` for this seed to its initial state. Returns a boolean value\\nindicating if the given seed has been used or not.\"},\"simplex\":{\"signatures\":[{\"params\":[{\"name\":\"x\"},{\"name\":\"y\"}]},{\"params\":[{\"name\":\"x\"},{\"name\":\"y\"},{\"name\":\"z\"}]},{\"params\":[{\"name\":\"x\"},{\"name\":\"y\"},{\"name\":\"z\"},{\"name\":\"seed\"}]}],\"docs\":\"Returns a noise value from `0.0` to `1.0` (roughly) for 2 or 3 dimensional coordinate. The default seed it samples\\nfrom is `0`, but seed can be specified as a 4th argument as well. In case you need 2D noise values with custom seed,\\nuse `null` for `z` argument.\\n\\nSimplex noise is based on a triangular grid and generates smoother maps comparing to Perlin. To sample 1D simplex\\nnoise, affix other coordinate to a constant.\\n\\nThou shall not sample from noise changing seed frequently. Scarpet will keep track of the last 256 simplex seeds\\nused for sampling providing similar speed comparing to the default seed of `0`. In case the app engine uses more\\nthan 256 seeds at the same time, switching between them can get much more expensive.\"},\"sleep\":{\"signatures\":[{\"params\":[{\"name\":\"\"}]}],\"docs\":\"`sleep(timeout)`, `sleep(timeout, close_expr)`\\n\\n\\nHalts the execution of the thread (or the game itself, if run not as a part of a task) for `expr` milliseconds.\\nIt checks for interrupted execution, in that case exits the thread (or the entire program, if not run on a thread) in case the app\\nis being stopped/removed. If the closing expression is specified, executes the expression when a shutdown signal is triggered.\\nIf run on the main thread (i.e. not as a task) the close expression may only be invoked when the entire game shuts down, so close call only\\nmakes sense for threads. For regular programs, use `__on_close()` handler.\\n\\nSince `close_expr` is executed after app shutdown is initiated, you won't be able to create new tasks in that block. Threads\\nshould periodically call `sleep` to ensure all app tasks will finish when the app is closing or right after, but the app engine\\nwill not forcefully remove your running tasks, so the tasks themselves need to properly react to the closing request.\\n\\n```scarpet\\nsleep(50)  # wait for 50 milliseconds\\nsleep(1000, print('Interrupted')) # waits for 1 second, outputs a message when thread is shut down.\\n```\"},\"slice\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"},{\"name\":\"from\"},{\"name\":\"to\"}]}],\"docs\":\"extracts a substring, or sublist (based on the type of the result of the expression under expr with\\nstarting index of `from`, and ending at `to` if provided, or the end, if omitted. Can use negative indices to\\nindicate counting form the back of the list, so `-1 <=> length(_)`.\\n\\nSpecial case is made for iterators (`range`, `rect` etc), which does require non-negative indices (negative `from` is treated as\\n`0`, and negative `to` as `inf`), but allows retrieving parts of the sequence and ignore\\nother parts. In that case consecutive calls to `slice` will refer to index `0` the current iteration position since iterators\\ncannot go back nor track where they are in the sequence (see examples).\\n\\n```scarpet\\nslice([0,1,2,3,4,5], 1, 3)  => [1, 2]\\nslice('foobar', 0, 1)  => 'f'\\nslice('foobar', 3)  => 'bar'\\nslice(range(10), 3, 5)  => [3, 4]\\nslice(range(10), 5)  => [5, 6, 7, 8, 9]\\nr = range(100); [slice(r, 5, 7), slice(r, 1, 3)]  => [[5, 6], [8, 9]]\\n```\"},\"sort\":{\"signatures\":[{\"params\":[{\"name\":\"list\"},{\"name\":\"sortvalues\"}]}],\"docs\":\"Sorts in the default sortographical order either all arguments, or a list if its the only argument.\\nIt returns a new sorted list, not affecting the list passed to the argument\\n\\n```scarpetsort(3,2,1)  => [1, 2, 3]\\nsort('a',3,11,1)  => [1, 3, 11, 'a']\\nlist = [4,3,2,1]; sort(list)  => [1, 2, 3, 4]\\n```\"},\"sort_key\":{\"signatures\":[{\"params\":[{\"name\":\"list\"},{\"name\":\"key_expr\"}]}],\"docs\":\"Sorts a copy of the list in the order or keys as defined by the `key_expr` for each element\\n\\n```scarpet\\nsort_key([1,3,2],_)  => [1, 2, 3]\\nsort_key([1,3,2],-_)  => [3, 2, 1]\\nsort_key([range(10)],rand(1))  => [1, 0, 9, 6, 8, 2, 4, 5, 7, 3]\\nsort_key([range(20)],str(_))  => [0, 1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 3, 4, 5, 6, 7, 8, 9]\\n```\"},\"split\":{\"signatures\":[{\"params\":[{\"name\":\"delim\"},{\"name\":\"expr\"}]}],\"docs\":\"Splits a string under `expr` by `delim` which can be a regular expression. If no delimiter is specified, it splits\\nby characters.\\n\\nIf `expr` is a list, it will split the list into multiple sublists by the element (s) which equal `delim`, or which equal the empty string\\nin case no delimiter is specified.\\n\\nSplitting a `null` value will return an empty list.\\n\\n```scarpet\\nsplit('foo') => [f, o, o]\\nsplit('','foo')  => [f, o, o]\\nsplit('.','foo.bar')  => []\\nsplit('\\\\\\\\.','foo.bar')  => [foo, bar]\\nsplit(1,[2,5,1,2,3,1,5,6]) => [[2,5],[2,3],[5,6]]\\nsplit(1,[1,2,3,1,4,5,1] => [[], [2,3], [4,5], []]\\nsplit(null) => []\\n```\"},\"str\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]},{\"params\":[{\"name\":\"expr\"},{\"name\":\"params\",\"rest\":true}]},{\"params\":[{\"name\":\"expr\"},{\"name\":\"param_list\"}]}],\"docs\":\"If called with one argument, returns string representation of such value.\\n\\nOtherwise, returns a formatted string representing the expression. Arguments for formatting can either be provided as\\n each consecutive parameter, or as a list which then would be the only extra parameter. To format one list argument\\n , you can use `str(list)`, or `str('foo %s', [list])`.\\n\\nAccepts formatting style accepted by `String.format`.\\nSupported types (with `\\\"%<?>\\\"` syntax):\\n\\n*   `d`, `o`, `x`: integers, octal, hex\\n*   `a`, `e`, `f`, `g`: floats\\n*   `b`: booleans\\n*   `s`: strings\\n*   `%%`: '%' character\\n\\n```scarpet\\nstr(null) => 'null'\\nstr(false) => 'false'\\nstr('') => ''\\nstr('3.14') => '3.14'\\nstr([]) => '[]'\\nstr(['']) => '[]'\\nstr('foo') => 'foo'\\nstr('3bar') => '3bar'\\nstr(2)+str(2) => '22'\\nstr('pi: %.2f',pi) => 'pi: 3.14'\\nstr('player at: %d, %d, %d',pos(player())) => 'player at: 567, -2423, 124'\\n```\"},\"synchronize\":{\"signatures\":[{\"params\":[{\"name\":\"lock\"},{\"name\":\"expression\"}]}],\"docs\":\"Evaluates `expression` synchronized with respect to the lock `lock`. Returns the value of the expression.\"},\"system_variable_get\":{\"signatures\":[{\"params\":[{\"name\":\"key\"},{\"name\":\"default_value\"}]}],\"docs\":\"Returns the variable from the system shared key-value storage keyed with a `key` value, optionally if value is\\nnot present, and default expression is provided, sets a new value to be associated with that key\"},\"system_variable_set\":{\"signatures\":[{\"params\":[{\"name\":\"key\"},{\"name\":\"new_value\"}]}],\"docs\":\"Returns the variable from the system shared key-value storage keyed with a `key` value, and sets a new\\nmapping for the key.\"},\"task\":{\"signatures\":[{\"params\":[{\"name\":\"function\"},{\"name\":\"args\"}]}],\"docs\":\", `task_thread(executor, function, ... args)`\\n\\nCreates and runs a parallel task, returning the handle to the task object. Task will return the return value of the\\nfunction when its completed, or will return `null` immediately if task is still in progress, so grabbing a value of\\na task object is non-blocking. Function can be either function value, or function lambda, or a name of an existing\\ndefined function. In case function needs arguments to be called with, they should be supplied after the function\\nname, or value. `executor` identifier in `task_thread`, places the task in a specific queue identified by this value.\\nThe default thread value is the `null` thread. There are no limits on number of parallel tasks for any executor,\\nso using different queues is solely for synchronization purposes.\\n\\n```scarpet\\ntask( _() -> print('Hello Other World') )  => Runs print command on a separate thread\\nfoo(a, b) -> print(a+b); task('foo',2,2)  => Uses existing function definition to start a task\\ntask_thread('temp', 'foo',3,5);  => runs function foo with a different thread executor, identified as 'temp'\\na = 3; task_thread('temp', _(outer(a), b) -> foo(a,b), 5)\\n    => Another example of running the same thing passing arguments using closure over anonymous function as well as passing a parameter.\\n```\\n\\nIn case you want to create a task based on a function that is not defined in your module, please read the tips on\\n \\\"Passing function references to other modules of your application\\\" section in the `call(...)` section.\"},\"task_completed\":{\"signatures\":[{\"params\":[{\"name\":\"task\"}]}],\"docs\":\"Returns true if task has completed, or false otherwise.\"},\"task_count\":{\"signatures\":[{\"params\":[{\"name\":\"executor\"}]}],\"docs\":\"If no argument provided, returns total number of tasks being executed in parallel at this moment using scarpet\\nthreading system. If the executor is provided, returns number of active tasks for that provider. Use `task_count(null)`\\nto get the task count of the default executor only.\"},\"task_dock\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"In a not-task (running regular code on the main game thread) it is a pass-through command. In tasks - it docks\\nthe current thread on the main server thread and executes expression as one server offline server task.\\nThis is especially helpful in case a task has several docking operations to perform, such as setting a block, and\\nit would be much more efficient to do them all at once rather then packing each block access in each own call.\\n\\nBe mindful, that docking the task means that the tick execution will be delayed until the expression is evaluated.\\nThis will synchronize your task with other tasks using `task_dock`, but if you should be using `synchronize` to\\nsynchronize tasks without locking the main thread.\"},\"task_join\":{\"signatures\":[{\"params\":[{\"name\":\"task\"}]}],\"docs\":\"Waits for the task completion and returns its computed value. If the task has already finished returns it immediately.\\nUnless taking the task value directly, i.e. via `task_value`, this operation is blocking. Since Minecraft has a\\nlimitation that all world access operations have to be performed on the main game thread in the off-tick time,\\njoining any tasks that use Minecraft API from the main thread would mean automatic lock, so joining from the main\\nthread is not allowed. Join tasks from other threads, if you really need to, or communicate asynchronously with\\nthe task via globals or function data / arguments to monitor its progress, communicate, get partial results,\\nor signal termination.\"},\"task_thread\":{\"signatures\":[{\"params\":[{\"name\":\"executor\"},{\"name\":\"function\"},{\"name\":\"args\",\"rest\":true}]}]},\"task_value\":{\"signatures\":[{\"params\":[{\"name\":\"task\"}]}],\"docs\":\"Returns the task return value, or `null` if task hasn't finished yet. Its a non-blocking operation. Unlike `join_task`,\\ncan be called on any task at any point\"},\"time\":{\"signatures\":[{\"params\":[]}],\"docs\":\"Returns the number of milliseconds since 'some point', like Java's `System.nanoTime()`, which varies from system to\\nsystem and from Java to Java. This measure should NOT be used to determine the current (date)time, but to measure\\ndurations of things.\\nit returns a float with time in milliseconds (ms) for convenience and microsecond (Î¼s) resolution for sanity.\\n\\n\\n```scarpet\\nstart_time = time();\\nflip_my_world_upside_down();\\nprint(str('this took %d milliseconds',time()-start_time))\\n```\"},\"title\":{},\"type\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Returns the string value indicating type of the expression. Possible outcomes\\nare `null`, `number`, `string`, `list`, `map`, `iterator`, `function`, `task`,\\nas well as minecraft related concepts like `block`, `entity`, `nbt`, `text`.\"},\"undef\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Removes all bindings of a variable with a name of `expr`. Removes also all function definitions with that name.\\nIt can affect global variable pool, and local variable set for a particular function.\\n\\n```scarpet\\ninc(i) -> i+1; foo = 5; inc(foo) => 6\\ninc(i) -> i+1; foo = 5; undef('foo'); inc(foo) => 1\\ninc(i) -> i+1; foo = 5; undef('inc'); undef('foo'); inc(foo) => Error: Function inc is not defined yet at pos 53\\n```\"},\"unix_time\":{\"signatures\":[{\"params\":[]}],\"docs\":\"Returns standard POSIX time as a number of milliseconds since the start of the epoch\\n(00:00 am and 0 seconds, 1 Jan 1970).\\n\\nUnlike the previous function, this can be used to get exact time, but it varies from time zone to time zone.\"},\"upper\":{},\"values\":{},\"var\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Returns the variable under the name of the string value of the expression. Allows to manipulate variables in more\\nprogrammatic manner, which allows to use local variable set with a hash map type key-value access,\\ncan also be used with global variables\\n\\n```scarpet\\na = 1; var('a') = 'foo'; a => a == 'foo'\\n```\"},\"vars\":{\"signatures\":[{\"params\":[{\"name\":\"prefix\"}]}],\"docs\":\"It returns all names of variables from local scope (if prefix does not start with 'global') or global variables\\n(otherwise). Here is a larger example that uses combination of `vars` and `var` functions to be\\nused for object counting\\n\\n```scarpet\\n/script run\\n$ count_blocks(ent) -> (\\n$   [cx, cy, cz] = query(ent, 'pos');\\n$   scan(cx, cy, cz, 16, 16, 16, var('count_'+_) += 1);\\n$   for ( sort_key( vars('count_'), -var(_)),\\n$     print(str( '%s: %d', slice(_,6), var(_) ))\\n$   )\\n$ )\\n/script run count_blocks(player())\\n```\"},\"abs\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Absolut value.\"},\"acos\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"acosh\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"acot\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"asin\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"asinh\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"atan\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"atan2\":{\"signatures\":[{\"params\":[{\"name\":\"x\"},{\"name\":\"y\"}]}]},\"atanh\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"ceil\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"First lucky integer that is not smaller than `n`. As you would expect, ceiling is typically right above the floor.\"},\"cos\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"cosh\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"cot\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"coth\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"csc\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"csch\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"deg\":{\"signatures\":[{\"params\":[{\"name\":\"rad\"}]}]},\"fact\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Factorial of a number, a.k.a `n!`, just not in `scarpet`. Gets big... quick... Therefore, values larger\\nthan `fact(20)` will not return the exact value, but a value with 'double-float' precision.\"},\"floor\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Returns the highest integer that is still no larger than `n`.\"},\"ln\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Natural logarithm of `n`. Naturally.\"},\"ln1p\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Natural logarithm of `n+1`. Very optimistic.\"},\"log\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Binary logarithm of `n`. Finally, a proper one, not like the previous 11.\"},\"log10\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Decimal logarithm of `n`. Its ceiling is the length of its floor.\"},\"log1p\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Binary logarithm of `n+1`. Also always positive.\"},\"mandelbrot\":{\"signatures\":[{\"params\":[{\"name\":\"a\"},{\"name\":\"b\"},{\"name\":\"limit\"}]}],\"docs\":\"Computes the value of the mandelbrot set, for set `a` and `b` spot. Spot the beetle. Why not.\"},\"max\":{\"signatures\":[{\"params\":[{\"name\":\"arg\"},{\"name\":\"args\",\"rest\":true}]},{\"params\":[{\"name\":\"list\"}]}],\"docs\":\"Compute minimum or maximum of supplied arguments assuming default sorthoraphical order.\\nIn case you are missing `argmax`, just use `a ~ max(a)`, little less efficient, but still fun.\\n\\nInteresting bit - `min` and `max` don't remove variable associations from arguments, which means can be used as\\nLHS of assignments (obvious case), or argument spec in function definitions (far less obvious).\\n\\n```scarpet\\na = 1; b = 2; min(a,b) = 3; [a,b]  => [3, 2]\\na = 1; b = 2; fun(x, min(a,b)) -> [a,b]; fun(3,5)  => [5, 0]\\n```\\n\\nAbsolutely no idea, how the latter might be useful in practice. But since it compiles, can ship it.\"},\"min\":{\"signatures\":[{\"params\":[{\"name\":\"arg\"},{\"name\":\"args\",\"rest\":true}]},{\"params\":[{\"name\":\"list\"}]}],\"docs\":\"Compute minimum or maximum of supplied arguments assuming default sorthoraphical order.\\nIn case you are missing `argmax`, just use `a ~ max(a)`, little less efficient, but still fun.\\n\\nInteresting bit - `min` and `max` don't remove variable associations from arguments, which means can be used as\\nLHS of assignments (obvious case), or argument spec in function definitions (far less obvious).\\n\\n```scarpet\\na = 1; b = 2; min(a,b) = 3; [a,b]  => [3, 2]\\na = 1; b = 2; fun(x, min(a,b)) -> [a,b]; fun(3,5)  => [5, 0]\\n```\\n\\nAbsolutely no idea, how the latter might be useful in practice. But since it compiles, can ship it.\"},\"rad\":{\"signatures\":[{\"params\":[{\"name\":\"deg\"}]}]},\"relu\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Linear rectifier of `n`. 0 below 0, n above. Why not. `max(0,n)` with less moral repercussions.\"},\"round\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Closest integer value. Did you know the earth is also round?\"},\"sec\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"sech\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"sin\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"sinh\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"sqrt\":{\"signatures\":[{\"params\":[{\"name\":\"n\"}]}],\"docs\":\"Square root (not 'a squirt') of a number. For other fancy roots, use `^`, math and yo noggin. Imagine square roots on a tree...\"},\"tan\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"tanh\":{\"signatures\":[{\"params\":[{\"name\":\"x\"}]}]},\"add_chunk_ticket\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"type\"},{\"name\":\"radius\"}]}],\"docs\":\"Adds a chunk ticket at a position, which makes the game to keep the designated area centered around\\n`pos` with radius of `radius` loaded for a predefined amount of ticks, defined by `type`. Allowed types\\nare `portal`: 300 ticks, `teleport`: 5 ticks, and `unknown`: 1 tick. Radius can be from 1 to 32 ticks.\\n\\nThis function is tentative - will likely change when chunk ticket API is properly fleshed out.\"},\"air\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if a block is air... or cave air... or void air... or any other air they come up with.\"},\"biome\":{\"signatures\":[{\"params\":[]},{\"params\":[{\"name\":\"name_or_block\"}]},{\"params\":[{\"name\":\"name_or_block\"},{\"name\":\"feature\"}]},{\"params\":\"noise_map\"}],\"docs\":\"Without arguments, returns the list of biomes in the world.\\n\\nWith block, or name, returns the name of the biome in that position, or throws `'unknown_biome'` if provided biome or block are not valid.\\n\\n(1.18+) if passed a map of `continentalness`, `depth`, `erosion`, `humidity`, `temperature`, `weirdness`, returns the biome that exists at those noise values.\\nNote: Have to pass all 6 of the mentioned noise types and only these noise types for it to evaluate a biome.\\n\\nWith an optional feature, it returns value for the specified attribute for that biome. Available and queryable features include:\\n* `'top_material'`: unlocalized block representing the top surface material (1.17.1 and below only)\\n* `'under_material'`: unlocalized block representing what sits below topsoil (1.17.1 and below only)\\n* `'category'`: the parent biome this biome is derived from. Possible values include (1.18.2 and below only):\\n`'none'`, `'taiga'`, `'extreme_hills'`, `'jungle'`, `'mesa'`, `'plains'`, `'savanna'`,\\n`'icy'`, `'the_end'`, `'beach'`, `'forest'`, `'ocean'`, `'desert'`, `'river'`,\\n`'swamp'`, `'mushroom'` , `'nether'`, `'underground'` (1.18+) and `'mountain'` (1.18+).\\n* `'tags'`: list of biome tags associated with this biome\\n* `'temperature'`: temperature from 0 to 1\\n* `'fog_color'`: RGBA color value of fog\\n* `'foliage_color'`: RGBA color value of foliage\\n* `'sky_color'`: RGBA color value of sky\\n* `'water_color'`: RGBA color value of water\\n* `'water_fog_color'`: RGBA color value of water fog\\n* `'humidity'`: value from 0 to 1 indicating how wet is the biome\\n* `'precipitation'`: `'rain'` `'snot'`, or `'none'`... ok, maybe `'snow'`, but that means snots for sure as well.\\n* `'depth'`: (1.17.1 and below only) float value indicating how high or low the terrain should generate. Values > 0 indicate generation above sea level\\nand values < 0, below sea level.\\n* `'scale'`: (1.17.1 and below only) float value indicating how flat is the terrain.\\n* `'features'`: list of features that generate in the biome, grouped by generation steps\\n* `'structures'`: (1.17.1 and below only) list of structures that generate in the biome.\"},\"blast_resistance\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, indicating blast_resistance of a block.\"},\"block\":{\"signatures\":[{\"params\":[{\"name\":\"x\"},{\"name\":\"y\"},{\"name\":\"z\"}]},{\"params\":[{\"name\":\"pos\"}]},{\"params\":[{\"name\":\"state\"}]}],\"docs\":\"Returns either a block from specified location, or block with a specific state (as used by `/setblock` command),\\nso allowing for block properties, block entity data etc. Blocks otherwise can be referenced everywhere by its simple\\nstring name, but its only used in its default state.\\n\\n```scarpet\\nblock('air')  => air\\nblock('iron_trapdoor[half=top]')  => iron_trapdoor\\nblock(0,0,0) == block('bedrock')  => 1\\nblock('hopper[facing=north]{Items:[{Slot:1b,id:\\\"minecraft:slime_ball\\\",Count:16b}]}') => hopper\\n```\\n\\nRetrieving a block with `block` function has also a side-effect of evaluating its current state and data.\\nSo if you use it later it will reflect block state and data of the block that was when block was called, rather than\\nwhen it was used. Block values passed in various places like `scan` functions, etc, are not fully evaluated unless\\nits properties are needed. This means that if the block at the location changes before its queried in the program this\\nmight result in getting the later state, which might not be desired. Consider the following example:\\n\\nThrows `unknown_block` if provided input is not valid.\\n\\n```scarpet\\nset(10,10,10,'stone');\\nscan(10,10,10,0,0,0, b = _);\\nset(10,10,10,'air');\\nprint(b); // 'air', block was remembered 'lazily', and evaluated by `print`, when it was already set to air\\nset(10,10,10,'stone');\\nscan(10,10,10,0,0,0, b = block(_));\\nset(10,10,10,'air');\\nprint(b); // 'stone', block was evaluated 'eagerly' but call to `block`\\n```\"},\"block_data\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Return NBT string associated with specific location, or null if the block does not carry block data. Can be currently\\nused to match specific information from it, or use it to copy to another block\\n\\n```scarpet\\nblock_data(x,y,z) => '{TransferCooldown:0,x:450,y:68, ... }'\\n```\"},\"block_light\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, returning the block light at position (from torches and other light sources).\"},\"block_list\":{\"signatures\":[{\"params\":[]},{\"params\":[{\"name\":\"tag\"}]}],\"docs\":\"Returns list of all blocks in the game. If `tag` is provided, returns list of all blocks that belong to this block tag.\\n```scarpet\\nblock_list() => [dark_oak_button, wall_torch, structure_block, polished_blackstone_brick_slab, cherry_sapling... ]\\nblock_list('impermeable') => [glass, white_stained_glass, orange_stained_glass, magenta_stained_glass... ] //All da glass\\nblock_list('rails') => [rail, powered_rail, detector_rail, activator_rail]\\nblock_list('not_a_valid_block_tag') => null //Not a valid block tag\\n```\"},\"block_properties\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Deprecated by `keys(block_state(pos))`.\"},\"block_sound\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Returns the name of sound type made by the block at position. One of:\\n\\n`'wood'`, `'gravel'`, `'grass'`, `'stone'`, `'metal'`, `'glass'`, `'wool'`, `'sand'`, `'snow'`,\\n`'ladder'`, `'anvil'`, `'slime'`, `'sea_grass'`, `'coral'`, `'bamboo'`', `'shoots'`', `'scaffolding'`', `'berry'`', `'crop'`',\\n`'stem'`', `'wart'`',\\n`'lantern'`', `'fungi_stem'`', `'nylium'`', `'fungus'`', `'roots'`', `'shroomlight'`', `'weeping_vines'`', `'soul_sand'`',\\n `'soul_soil'`', `'basalt'`',\\n`'wart'`', `'netherrack'`', `'nether_bricks'`', `'nether_sprouts'`', `'nether_ore'`', `'bone'`', `'netherite'`', `'ancient_debris'`',\\n`'lodestone'`', `'chain'`', `'nether_gold_ore'`', `'gilded_blackstone'`',\\n`'candle'`', `'amethyst'`', `'amethyst_cluster'`', `'small_amethyst_bud'`', `'large_amethyst_bud'`', `'medium_amethyst_bud'`',\\n`'tuff'`', `'calcite'`', `'copper'`'\"},\"block_state\":{\"signatures\":[{\"params\":[{\"name\":\"block\"}]},{\"params\":[{\"name\":\"block\"},{\"name\":\"property\"}]}],\"docs\":\", `block_state(block, property)`\\n\\nIf used with a `block` argument only, it returns a map of block properties and their values.  If a block has no properties, returns an\\nempty map.\\n\\nIf `property` is specified, returns a string value of that property, or `null` if property is not applicable.\\n\\nReturned values or properties are always strings. It is expected from the user to know what to expect and convert\\nvalues to numbers using `number()` function or booleans using `bool()` function. Returned string values can be directly used\\nback in state definition in various applications where block properties are required.\\n\\n`block_state` can also accept block names as input, returning block's default state.\\n\\nThrows `unknown_block` if the provided input is not valid.\\n\\n```scarpet\\nset(x,y,z,'iron_block'); block_state(x,y,z)  => {}\\nset(x,y,z,'iron_trapdoor','half','top'); block_state(x,y,z)  => {waterlogged: false, half: top, open: false, ...}\\nset(x,y,z,'iron_trapdoor','half','top'); block_state(x,y,z,'half')  => top\\nblock_state('iron_trapdoor','half')  => top\\nset(x,y,z,'air'); block_state(x,y,z,'half')  => null\\nblock_state(block('iron_trapdoor[half=top]'),'half')  => top\\nblock_state(block('iron_trapdoor[half=top]'),'powered')  => false\\nbool(block_state(block('iron_trapdoor[half=top]'),'powered'))  => 0\\n```\"},\"block_tags\":{\"signatures\":[{\"params\":[]},{\"params\":[{\"name\":\"block\"}]},{\"params\":[{\"name\":\"block\"},{\"name\":\"tag\"}]}],\"docs\":\", `block_tags(block)`, `block_tags(block, tag)`\\n\\nWithout arguments, returns list of available tags, with block supplied (either by coordinates, or via block name), returns lost\\nof tags the block belongs to, and if a tag is specified, returns `null` if tag is invalid, `false` if this block doesn't belong\\nto this tag, and `true` if the block belongs to the tag.\\n\\nThrows `unknown_block` if `block` doesn't exist\\n\\n```scarpet\\nblock_tags() => [geode_invalid_blocks, wall_post_override, ice, wooden_stairs, bamboo_blocks, stone_bricks... ]\\nblock_tags('iron_block') => [mineable/pickaxe, needs_stone_tool, beacon_base_blocks]\\nblock_tags('glass') => [impermeable]\\nblock_tags('glass', 'impermeable') => true\\nblock_tags('glass', 'beacon_base_blocks') => false\\n```\"},\"block_tick\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Causes a block to tick at position.\"},\"blocks_daylight\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block blocks daylight.\"},\"blocks_movement\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block at position blocks movement.\"},\"crafting_remaining_item\":{\"signatures\":[{\"params\":[{\"name\":\"item\"}]}],\"docs\":\"returns `null` if the item has no remaining item in the crafting window when used as a crafting ingredient, or an\\nitem name that serves as a replacement after crafting is done. Currently it can only be buckets and glass bottles.\"},\"create_explosion\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"power\"},{\"name\":\"mode\"},{\"name\":\"fire\"},{\"name\":\"source\"},{\"name\":\"attacker\"}]}],\"docs\":\"Creates an explosion at a given position. Parameters work as follows:\\n - `'power'` - how strong the blast is, negative values count as 0 (default: `4` (TNT power))\\n - `'mode'` - how to deal with broken blocks: `keep` keeps them, `destroy` destroys them and drops items, and `destroy_with_decay` destroys them, but doesn't always drop the items (default: `destroy_with_decay`)\\n - `fire` - whether extra fire blocks should be created (default: `false`)\\n - `source` - entity that is exploding. Note that it will not take explosion damage from this explosion (default: `null`)\\n - `attacker` - entity responsible for triggering, this will be displayed in death messages, and count towards kill counts, and can be damaged by the explosion (default: `null`)\\nExplosions created with this endpoint cannot be captured with `__on_explosion` event, however they will be captured\\nby `__on_explosion_outcome`.\"},\"destroy\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"destroypos\"},{\"name\":\"1\"},{\"name\":\"destroypos\"},{\"name\":\"N\"},{\"name\":\"destroypos\"},{\"name\":\"tool\"},{\"name\":\"nbt\"}]}],\"docs\":\"Destroys the block like it was mined by a player. Add -1 for silk touch, and a positive number for fortune level.\\nIf tool is specified, and optionally its nbt, it will use that tool and will attempt to mine the block with this tool.\\nIf called without item context, this function, unlike harvest, will affect all kinds of blocks. If called with item\\nin context, it will fail to break blocks that cannot be broken by a survival player.\\n\\nWithout item context it returns `false` if failed to destroy the block and `true` if block breaking was successful.\\nIn item context, `true` means that breaking item has no nbt to use, `null` indicating that the tool should be\\nconsidered broken in process, and `nbt` type value, for a resulting NBT tag on a hypothetical tool. Its up to the\\nprogrammer to use that nbt to apply it where it belong\\n\\nThrows `unknown_item` if `tool` doesn't exist.\\n\\nHere is a sample code that can be used to mine blocks using items in player inventory, without using player context\\nfor mining. Obviously, in this case the use of `harvest` would be much more applicable:\\n\\n```scarpet\\nmine(x,y,z) ->\\n(\\n  p = player();\\n  slot = p~'selected_slot';\\n  item_tuple = inventory_get(p, slot);\\n  if (!item_tuple, destroy(x,y,z,'air'); return()); // empty hand, just break with 'air'\\n  [item, count, tag] = item_tuple;\\n  tag_back = destroy(x,y,z, item, tag);\\n  if (tag_back == false, // failed to break the item\\n    return(tag_back)\\n  );\\n  if (tag_back == true, // block broke, tool has no tag\\n    return(tag_back)\\n  );\\n  if (tag_back == null, //item broke\\n    delete(tag:'Damage');\\n    inventory_set(p, slot, count-1, item, tag);\\n    return(tag_back)\\n  );\\n  if (type(tag_back) == 'nbt', // item didn't break, here is the effective nbt\\n    inventory_set(p, slot, count, item, tag_back);\\n    return(tag_back)\\n  );\\n  print('How did we get here?');\\n)\\n```\"},\"diamond\":{\"signatures\":[{\"params\":[{\"name\":\"center_pos\"},{\"name\":\"radius\"},{\"name\":\"height\"}]}],\"docs\":\"Iterates over a diamond like area of blocks. With no radius and height, its 7 blocks centered around the middle\\n(block + neighbours). With a radius specified, it expands shape on x and z coords, and with a custom height, on y.\\nAny of these can be zero as well. radius of 0 makes a stick, height of 0 makes a diamond shape pad.\\n\\nIf radius and height are the same, creats a 3D diamond, of all the blocks which are a manhattan distance of `radius` away\\nfrom the center.\"},\"drop_item\":{\"signatures\":[{\"params\":[{\"name\":\"inventory\"},{\"name\":\"slot\"},{\"name\":\"amount\"},{\"name\":\"\"}]}],\"docs\":\"Drops the items from indicated inventory slot, like player that Q's an item or villager, that exchanges food.\\nYou can Q items from block inventories as well. default amount is 0 - which is all from the slot.\\nNOTE: hoppers are quick enough to pick all the queued items from their inventory anyways.\\nReturns size of the actual dropped items.\\n\\n```scarpet\\ninventory_drop(player(), 0, 1) => 1 // Q's one item on the ground\\ninventory_drop(x,y,z, 0) => 64 // removed and spawned in the world a full stack of items\\n```\"},\"effective_light\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, returning the \\\"real\\\" light at position, which is affected by time and weather. which also affects mobs spawning, frosted ice blocks melting.\"},\"emitted_light\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, returning the light level emitted from the block.\"},\"entity_area\":{\"signatures\":[{\"params\":[{\"name\":\"type\"},{\"name\":\"center\"},{\"name\":\"distance\"}]}],\"docs\":\"Returns entities of a specified type in an area centered on `center` and at most `distance` blocks away from\\nthe center point/area. Uses the same `type` selectors as `entities_list`.\\n\\n`center` and `distance` can either be a triple of coordinates or three consecutive arguments for `entity_area`. `center` can\\nalso be represented as a block, in this case the search box will be centered on the middle of the block, or an entity - in this case\\nentire bounding box of the entity serves as a 'center' of search which is then expanded in all directions with the `'distance'` vector.\\n\\nIn any case - returns all entities which bounding box collides with the bounding box defined by `'center'` and `'distance'`.\\n\\nentity_area is simpler than `entity_selector` and runs about 20% faster, but is limited to predefined selectors and\\ncuboid search area.\"},\"entity_event\":{\"signatures\":[{\"params\":[{\"name\":\"e\"},{\"name\":\"event\"},{\"name\":\"function\"}]}],\"docs\":\", `entity_event(e, event, call_name, ... args?)`\\n\\nAttaches specific function from the current package to be called upon the `event`, with extra `args` carried to the\\noriginal required arguments for the event handler.\\n\\n```scarpet\\nprotect_villager(entity, amount, source, source_entity, healing_player) ->\\n(\\n   if(source_entity && source_entity~'type' != 'player',\\n      modify(entity, 'health', amount + entity~'health' );\\n      particle('end_rod', pos(entity)+[0,3,0]);\\n      print(str('%s healed thanks to %s', entity, healing_player))\\n   )\\n);\\n__on_player_interacts_with_entity(player, entity, hand) ->\\n(\\n   if (entity~'type' == 'villager',\\n      entity_event(entity, 'on_damage', 'protect_villager', player~'name')\\n   )\\n)\\n```\\n\\nIn this case this will protect a villager from entity damage (zombies, etc.) except from players by granting all the\\nhealth back to the villager after being harmed.\"},\"entity_id\":{\"signatures\":[{\"params\":[{\"name\":\"uuid\"},{\"name\":\"entity_idid\"}]}],\"docs\":\"Fetching entities either by their ID obtained via `entity ~ 'id'`, which is unique for a dimension and current world\\nrun, or by UUID, obtained via `entity ~ 'uuid'`. It returns null if no such entity is found. Safer way to 'store'\\nentities between calls, as missing entities will be returning `null`. Both calls using UUID or numerical ID are `O(1)`,\\nbut obviously using UUIDs takes more memory and compute.\"},\"entity_list\":{\"signatures\":[{\"params\":[{\"name\":\"descriptor\"}]}],\"docs\":\"Returns global lists of entities in the current dimension matching specified descriptor.\\nCalls to `entity_list` always fetch entities from the current world that the script executes.\"},\"entity_load_handler\":{\"signatures\":[{\"params\":[{\"name\":\"descriptor\"},{\"name\":\"function\"},{\"name\":\"args\",\"rest\":true}]}],\"docs\":\"Attaches a callback to trigger when any entity matching the following type / types is loaded in the game, allowing to grab a handle\\nto an entity right when it is loaded to the world without querying them every tick. Callback expects two parameters - the entity,\\nand a boolean value indicating if the entity was newly created(`true`) or just loaded from disk. Single argument functions accepting\\nonly entities are allowed, but deprecated and will be removed at some point.\\n\\nIf callback is `null`, then the current entity handler, if present, is removed. Consecutive calls to `entity_load_handler` will add / subtract\\nof the currently targeted entity types pool.\\n\\nLike other global events, calls to `entity_load_handler` should only be attached in apps with global scope. For player scope apps,\\nit will be called multiple times, once for each player. That's likely not what you want to do.\\n\\n```scarpet\\n// veryfast method of getting rid of all the zombies. Callback is so early, its packets haven't reached yet the clients\\n// so to save on log errors, removal of mobs needs to be scheduled for later.\\nentity_load_handler('zombie', _(e, new) -> schedule(0, _(outer(e)) -> modify(e, 'remove')))\\n\\n// another way to do it is to remove the entity when it starts ticking\\nentity_load_handler('zombie', _(e, new) -> entity_event(e, 'on_tick', _(e) -> modify(e, 'remove')))\\n\\n// making all zombies immediately faster and less susceptible to friction of any sort\\nentity_load_handler('zombie', _(e, new) -> entity_event(e, 'on_tick', _(e) -> modify(e, 'motion', 1.2*e~'motion')))\\n```\\n\\nWord of caution: entities can be loaded with chunks in various states, for instance when a chunk is being generated, this means\\nthat accessing world blocks would cause the game to freeze due to force generating that chunk while generating the chunk. Make\\nsure to never assume the chunk is ready and use `entity_load_handler` to schedule actions around the loaded entity,\\nor manipulate entity directly.\\n\\nAlso, it is possible that mobs that spawn with world generation, while being 'added' have their metadata serialized and cached\\ninternally (vanilla limitation), so some modifications to these entities may have no effect on them. This affects mobs created with\\nworld generation.\\n\\nFor instance the following handler is safe, as it only accesses the entity directly. It makes all spawned pigmen jump\\n\\n```\\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, modify(e, 'motion', 0, 1, 0)) )\\n```\\n\\nBut the following handler, attempting to despawn pigmen that spawn in portals, will cause the game to freeze due to cascading access to blocks that would cause neighbouring chunks\\nto force generate, causing also error messages for all pigmen caused by packets send after entity is removed by script.\\n\\n```\\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new && block(pos(e))=='nether_portal', modify(e, 'remove') ) )\\n```\\n\\nEasiest method to circumvent these issues is delay the check, which may or may not cause cascade load to happen, but\\nwill definitely break the infinite chain.\\n\\n```\\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, schedule(0, _(outer(e)) -> if(block(pos(e))=='nether_portal', modify(e, 'remove') ) ) ) )\\n```\\n\\nBut the best is to perform the check first time the entity will be ticked - giving the game all the time to ensure chunk\\nis fully loaded and entity processing, removing the tick handler:\\n\\n```\\n/script run entity_load_handler('zombified_piglin', _(e, new) -> if(new, entity_event(e, 'on_tick', _(e) -> ( if(block(pos(e))=='nether_portal', modify(e, 'remove')); entity_event(e, 'on_tick', null) ) ) ) )\\n```\\n\\nLooks little convoluted, but that's the safest method to ensure your app won't crash.\"},\"entity_selector\":{\"signatures\":[{\"params\":[{\"name\":\"selector\"}]}],\"docs\":\"Returns entities satisfying given vanilla entity selector. Most complex among all the methods of selecting entities,\\nbut the most capable. Selectors are cached so it should be as fast as other methods of selecting entities. Unlike other\\nentities fetching / filtering method, this one doesn't guarantee to return entities from current dimension, since\\nselectors can return any loaded entity in the world.\"},\"entity_types\":{\"signatures\":[{\"params\":[{\"name\":\"descriptor\"}]}],\"docs\":\"Resolves a given descriptor returning list of entity types that match it. The returned list of types is also a valid list\\nof descriptors that can be use elsewhere where entity types are required.\\n\\nCurrently, the following descriptors are available:\\n\\n*  `*`: all entities, even `!valid`, matches all entity types.\\n*  `valid` - all entities that are not dead (health > 0). All main categories below also return only\\nentities in the `valid` category. matches all entity types. `!valid` matches all entites that are already dead of all types.\\n*  `living` - all entities that resemble a creature of some sort\\n*  `projectile` - all entities or types that are not living that can be throw or projected, `!projectile` matches all types that\\n   are not living, but cannot the thrown or projected.\\n*  `minecarts` matches all minecart types. `!minecarts` matches all types that are not live, but also not minecarts. Using plural\\nsince `minecart` is a proper entity type on its own.\\n*  `undead`, `arthropod`, `aquatic`, `regular`, `illager` - all entities / types that belong to any of these groups. All\\nliving entities belong to one and only one of these. Corresponding negative (e.g. `!undead`) corresponds to all mobs that are\\nliving but don't belong to that group. Entity groups are used in interaction / battle mechanics like smite for undead, or impaling\\nfor aquatic. Also certain mechanics interact with groups, like ringing a bell with illagers. All other mobs that don't have any of these traits belong\\nto the `regular` group.\\n*  `monster`, `creature`, `ambient`, `water_creature`, `water_ambient`, `misc` - another categorization of\\nliving entities based on their spawn group. Negative descriptor resolves to all living types that don't belong to that\\ncategory.\\n* All entity tags including those provided with datapacks. Built-in entity tags include: `skeletons`, `raiders`,\\n`beehive_inhabitors` (bee, duh), `arrows` and `impact_projectiles`.\\n* Any of the standard entity types, equivalent to selection from `/summon` vanilla command, which is one of the options returned\\nby `entity_types()`, except for `'fishing_bobber'` and `'player'`.\\n\\nAll categories can be preceded with `'!'` which will fetch all entities (unless otherwise noted) that are valid (health > 0) but not\\nbelonging to that group.\"},\"flammable\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block is flammable.\"},\"generation_status\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"generation_statuspos\"},{\"name\":\"true\"}]}],\"docs\":\"Returns generation status as per the ticket system. Can return any value from several available but chunks\\ncan only be stable in a few states: `full`, `features`, `liquid_carvers`, and `structure_starts`. Returns `null`\\nif the chunk is not in memory unless called with optional `true`.\"},\"hardness\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, indicating hardness of a block.\"},\"harvest\":{\"signatures\":[{\"params\":[{\"name\":\"player\"},{\"name\":\"pos\"}]}],\"docs\":\"Causes a block to be harvested by a specified player entity. Honors player item enchantments, as well as damages the\\ntool if applicable. If the entity is not a valid player, no block gets destroyed. If a player is not allowed to break\\nthat block, a block doesn't get destroyed either.\"},\"in_slime_chunk\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean indicating if the given block position is in a slime chunk.\"},\"inhabited_time\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Returns inhabited time for a chunk.\"},\"inventory_find\":{\"signatures\":[{\"params\":[{\"name\":\"inventory\"},{\"name\":\"item\"},{\"name\":\"start_slot\"},{\"name\":\"\"},{\"name\":\"inventory_findinventory\"},{\"name\":\"null\"},{\"name\":\"start_slot\"}]}],\"docs\":\"Finds the first slot with a corresponding item in the inventory, or if queried with null: the first empty slot.\\nReturns slot number if found, or null otherwise. Optional start_slot argument allows to skip all preceeding slots\\nallowing for efficient (so not slot-by-slot) inventory search for items.\\n\\n```scarpet\\ninventory_find(player(), 'stone') => 0 // player has stone in first hotbar slot\\ninventory_find(player(), null) => null // player's inventory has no empty spot\\nwhile( (slot = inventory_find(p, 'diamond', slot)) != null, 41, drop_item(p, slot) )\\n    // spits all diamonds from player inventory wherever they are\\ninventory_drop(x,y,z, 0) => 64 // removed and spawned in the world a full stack of items\\n```\\n\\nThrows `unknown_item` if item doesn't exist.\"},\"inventory_get\":{\"signatures\":[{\"params\":[{\"name\":\"inventory\"},{\"name\":\"slot\"}]}],\"docs\":\"Returns the item in the corresponding inventory slot, or null if slot empty or inventory is invalid. You can use\\nnegative numbers to indicate slots counted from 'the back'.\\n\\n```scarpet\\ninventory_get(player(), 0) => null // nothing in first hotbar slot\\ninventory_get(x,y,z, 5) => ['stone', 1, {}]\\ninventory_get(player(), -1) => ['diamond_pickaxe', 1, {Damage:4}] // slightly damaged diamond pick in the offhand\\n```\"},\"inventory_has_items\":{\"signatures\":[{\"params\":[{\"name\":\"inventory\"}]}],\"docs\":\"Returns true, if the inventory is not empty, false if it is empty, and null, if its not an inventory.\\n\\n```scarpet    inventory_has_items(player()) => true\\n    inventory_has_items(x,y,z) => false // empty chest\\n    inventory_has_items(block(pos)) => null // stone\\n```\"},\"inventory_remove\":{\"signatures\":[{\"params\":[{\"name\":\"inventory\"},{\"name\":\"item\"},{\"name\":\"amount\"}]}],\"docs\":\"Removes amount (defaults to 1) of item from inventory. If the inventory doesn't have the defined amount, nothing\\nhappens, otherwise the given amount of items is removed wherever they are in the inventory. Returns boolean\\nwhether the removal operation was successful. Easiest way to remove a specific item from player inventory\\nwithout specifying the slot.\\n\\n```scarpet\\ninventory_remove(player(), 'diamond') => 1 // removed diamond from player inventory\\ninventory_remove(player(), 'diamond', 100) => 0 // player doesn't have 100 diamonds, nothing happened\\n```\"},\"inventory_set\":{\"signatures\":[{\"params\":[{\"name\":\"inventory\"},{\"name\":\"slot\"},{\"name\":\"count\"},{\"name\":\"item\"},{\"name\":\"nbt\"}]}],\"docs\":\"Modifies or sets a stack in inventory. specify count 0 to empty the slot. If item is not specified, keeps existing\\nitem, just modifies the count. If item is provided - replaces current item. If nbt is provided - adds a tag to the\\nstack at slot. Returns previous stack in that slot.\\n\\n```scarpet\\ninventory_set(player(), 0, 0) => ['stone', 64, {}] // player had a stack of stone in first hotbar slot\\ninventory_set(player(), 0, 6) => ['diamond', 64, {}] // changed stack of diamonds in player slot to 6\\ninventory_set(player(), 0, 1, 'diamond_axe','{Damage:5}') => null //added slightly damaged diamond axe to first player slot\\n```\"},\"inventory_size\":{\"signatures\":[{\"params\":[{\"name\":\"inventory\"}]}],\"docs\":\"Returns the size of the inventory for the entity or block in question. Returns null if the block or entity don't\\nhave an inventory.\\n\\n```scarpet\\ninventory_size(player()) => 41\\ninventory_size('enderchest', player()) => 27 // enderchest\\ninventory_size('equipment', player()) => 6 // equipment\\ninventory_size(null, player()) => 41  // default inventory for players\\n\\ninventory_size(x,y,z) => 27 // chest\\ninventory_size(block(pos)) => 5 // hopper\\n\\nhorse = spawn('horse', x, y, z);\\ninventory_size(horse); => 2 // default horse inventory\\ninventory_size('equipment', horse); => 6 // unused horse equipment inventory\\ninventory_size(null, horse); => 2 // default horse\\n\\ncreeper = spawn('creeper', x, y, z);\\ninventory_size(creeper); => 6 // default creeper inventory is equipment since it has no other\\ninventory_size('equipment', creeper); => 6 // unused horse equipment inventory\\ninventory_size(null, creeper); => 6 // creeper default is its equipment\\n```\"},\"is_chunk_generated\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\", `is_chunk_generated(pos, force)`\\n\\nReturns `true` if the region file for the chunk exists,\\n`false` otherwise. If optional force is `true` it will also check if the chunk has a non-empty entry in its region file\\nCan be used to assess if the chunk has been touched by the game or not.\\n\\n`generation_status(pos, false)` only works on currently loaded chunks, and `generation_status(pos, true)` will create\\nan empty loaded chunk, even if it is not needed, so `is_chunk_generated` can be used as a efficient proxy to determine\\nif the chunk physically exists.\\n\\nRunning `is_chunk_generated` is has no effects on the world, but since it is an external file operation, it is\\nconsiderably more expensive (unless area is loaded) than other generation and loaded checks.\"},\"item_list\":{\"signatures\":[{\"params\":[{\"name\":\"tag\"}]}],\"docs\":\"With no arguments, returns a list of all items in the game. With an item tag provided, list items matching the tag, or `null` if tag is not valid.\"},\"item_tags\":{\"signatures\":[{\"params\":[{\"name\":\"item\"},{\"name\":\"tag\"}]}],\"docs\":\"Returns list of tags the item belongs to, or, if tag is provided, `true` if an item matches the tag, `false` if it doesn't and `null` if that's not a valid tag\\n\\nThrows `unknown_item` if item doesn't exist.\"},\"light\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, returning the total light level at position.\"},\"liquid\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block is liquid, or waterlogged (with any liquid).\"},\"loaded\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block is accessible for the game mechanics. Normally `scarpet` doesn't check if operates\\non loaded area - the game will automatically load missing blocks. We see this as an advantage. Vanilla `fill/clone`\\ncommands only check the specified corners for loadness.\\n\\nTo check if a block is truly loaded, I mean in memory, use `generation_status(x) != null`, as chunks can still be loaded\\noutside of the playable area, just are not used by any of the game mechanic processes.\\n\\n```scarpet\\nloaded(pos(player()))  => 1\\nloaded(100000,100,1000000)  => 0\\n```\"},\"loaded_ep\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block is loaded and entity processing, as per 1.13.2\\n\\nDeprecated as of scarpet 1.6, use `loaded_status(x) > 0`, or just `loaded(x)` with the same effect\"},\"loaded_status\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Returns loaded status as per new 1.14 chunk ticket system, 0 for inaccessible, 1 for border chunk, 2 for redstone ticking,\\n3 for entity ticking\"},\"map_colour\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Returns the map colour of a block at position. One of:\\n\\n`'air'`, `'grass'`, `'sand'`, `'wool'`, `'tnt'`, `'ice'`, `'iron'`, `'foliage'`, `'snow'`, `'clay'`, `'dirt'`,\\n`'stone'`, `'water'`, `'wood'`, `'quartz'`, `'adobe'`, `'magenta'`, `'light_blue'`, `'yellow'`, `'lime'`, `'pink'`,\\n`'gray'`, `'light_gray'`, `'cyan'`, `'purple'`, `'blue'`, `'brown'`, `'green'`, `'red'`, `'black'`, `'gold'`,\\n`'diamond'`, `'lapis'`, `'emerald'`, `'obsidian'`, `'netherrack'`, `'white_terracotta'`, `'orange_terracotta'`,\\n`'magenta_terracotta'`, `'light_blue_terracotta'`, `'yellow_terracotta'`, `'lime_terracotta'`, `'pink_terracotta'`,\\n`'gray_terracotta'`, `'light_gray_terracotta'`, `'cyan_terracotta'`, `'purple_terracotta'`, `'blue_terracotta'`,\\n`'brown_terracotta'`, `'green_terracotta'`, `'red_terracotta'`, `'black_terracotta'`,\\n`'crimson_nylium'`, `'crimson_stem'`, `'crimson_hyphae'`, `'warped_nylium'`, `'warped_stem'`, `'warped_hyphae'`, `'warped_wart'`\"},\"material\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Returns `'unknown'`. The concept of material for blocks is removed. On previous versions it returned the name of the material the block\\nwas made of.\"},\"neighbours\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Returns the list of 6 neighbouring blocks to the argument. Commonly used with other loop functions like `for`.\\n\\n```scarpet\\nfor(neighbours(x,y,z),air(_)) => 4 // number of air blocks around a block\\n```\"},\"opacity\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, returning the opacity level of a block.\"},\"place_item\":{\"signatures\":[{\"params\":[{\"name\":\"item\"},{\"name\":\"pos\"},{\"name\":\"facing\"},{\"name\":\"sneak\"}]}],\"docs\":\"Uses a given item in the world like it was used by a player. Item names are default minecraft item name,\\nless the minecraft prefix. Default facing is 'up', but there are other options: 'down', 'north', 'east', 'south',\\n'west', but also there are other secondary directions important for placement of blocks like stairs, doors, etc.\\nTry experiment with options like 'north-up' which is placed facing north with cursor pointing to the upper part of the\\nblock, or 'up-north', which means a block placed facing up (player looking down) and placed smidge away of the block\\ncenter towards north. Optional sneak is a boolean indicating if a player would be sneaking while placing the\\nblock - this option only affects placement of chests and scaffolding at the moment.\\n\\nWorks with items that have the right-click effect on the block placed, like `bone_meal` on grass or axes on logs,\\nbut doesn't open chests / containers, so have no effect on interactive blocks, like TNT, comparators, etc.\\n\\nReturns true if placement/use was\\nsuccessful, false otherwise.\\n\\nThrows `unknown_item` if `item` doesn't exist\\n\\n```scarpet\\nplace_item('stone',x,y,z) // places a stone block on x,y,z block\\nplace_item('piston,x,y,z,'down') // places a piston facing down\\nplace_item('carrot',x,y,z) // attempts to plant a carrot plant. Returns true if could place carrots at that position.\\nplace_item('bone_meal',x,y,z) // attempts to bonemeal the ground.\\nplace_item('wooden_axe',x,y,z) // attempts to strip the log.\\n```\"},\"player\":{\"signatures\":[{\"params\":[{\"name\":\"\"},{\"name\":\"playertype\"},{\"name\":\"playername\"}]}],\"docs\":\"With no arguments, it returns the calling player or the player closest to the caller.\\nFor player-scoped apps (which is a default) its always the owning player or `null` if it not present even if some code\\nstill runs in their name.\\nNote that the main context\\nwill receive `p` variable pointing to this player. With `type` or `name` specified, it will try first to match a type,\\nreturning a list of players matching a type, and if this fails, will assume its player name query retuning player with\\nthat name, or `null` if no player was found. With `'all'`, list of all players in the game, in all dimensions, so end\\nuser needs to be cautious, that you might be referring to wrong blocks and entities around the player in question.\\nWith `type = '*'` it returns all players in caller dimension, `'survival'` returns all survival and adventure players,\\n`'creative'` returns all creative players, `'spectating'` returns all spectating players, and `'!spectating'`,\\nall not-spectating players. If all fails, with `name`, the player in question, if he/she is logged in.\"},\"plop\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"what\"}]}],\"docs\":\"Plops a structure or a feature at a given `pos`, so block, triple position coordinates or a list of coordinates.\\nTo `what` gets plopped and exactly where it often depends on the feature or structure itself.\\n\\nRequires a `Structure Type`,  `Structure`, `World Generation Feature` or `Custom Scarpet Feature` name (see\\nabove). If standard name is used, the variant of the structure may depend on the biome, otherwise the default\\nstructure for this type will be generated.\\n\\nAll structures are chunk aligned, and often span multiple chunks. Repeated calls to plop a structure in the same chunk\\nwould result either in the same structure generated on top of each other, or with different state, but same position.\\nMost structures generate at specific altitudes, which are hardcoded, or with certain blocks around them. API will\\ncancel all extra position / biome / random requirements for structure / feature placement, but some hardcoded\\nlimitations may still cause some of structures/features not to place. Some features require special blocks to be\\npresent, like coral -> water or ice spikes -> snow block, and for some features, like fossils, placement is all sorts\\nof messed up. This can be partially avoided for structures by setting their structure information via `set_structure`,\\nwhich sets it without looking into world blocks, and then use `plop` to fill it with blocks. This may, or may not work.\\n\\nAll generated structures will retain their properties, like mob spawning, however in many cases the world / dimension\\nitself has certain rules to spawn mobs, like plopping a nether fortress in the overworld will not spawn nether mobs,\\nbecause nether mobs can spawn only in the nether, but plopped in the nether - will behave like a valid nether fortress.\\n# Iterating over larger areas of blocks\\n\\nThese functions help scan larger areas of blocks without using generic loop functions, like nested `loop`.\"},\"poi\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"poipos\"},{\"name\":\"radius\"},{\"name\":\"type\"},{\"name\":\"status\"},{\"name\":\"column_search\"}]}],\"docs\":\"Queries a POI (Point of Interest) at a given position, returning `null` if none is found, or tuple of poi type and its\\noccupancy load. With optional `type`, `radius` and `status`, returns a list of POIs around `pos` within a\\ngiven `radius`. If the `type` is specified, returns only poi types of that types, or everything if omitted or `'any'`.\\nIf `status` is specified (either `'any'`, `'available'`, or `'occupied'`) returns only POIs with that status.\\nWith `column_search` set to `true`, it will return all POIs in a cuboid with `radius` blocks away on x and z, in the entire\\nblock column from 0 to 255. Default (`false`) returns POIs within a spherical area centered on `pos` and with `radius`\\nradius.\\n\\nAll results of `poi` calls are returned in sorted order with respect to the euclidean distance to the requested center of `pos`.\\n\\nThe return format of the results is a list of poi type, occupancy load, and extra triple of coordinates.\\n\\nQuerying for POIs using the radius is the intended use of POI mechanics, and the ability of accessing individual POIs\\nvia `poi(pos)` in only provided for completeness.\\n\\n```scarpet\\npoi(x,y,z) => null  // nothing set at position\\npoi(x,y,z) => ['meeting',3]  // its a bell-type meeting point occupied by 3 villagers\\npoi(x,y,z,5) => []  // nothing around\\npoi(x,y,z,5) => [['nether_portal',0,[7,8,9]],['nether_portal',0,[7,9,9]]] // two portal blocks in the range\\n```\"},\"pos\":{\"signatures\":[{\"params\":[{\"name\":\"block\"},{\"name\":\"posentity\"}]}],\"docs\":\"Returns a triple of coordinates of a specified block or entity. Technically entities are queried with `query` function\\nand the same can be achieved with `query(entity,'pos')`, but for simplicity `pos` allows to pass all positional objects.\\n\\n```scarpet\\npos(block(0,5,0)) => [0,5,0]\\npos(player()) => [12.3, 45.6, 32.05]\\npos(block('stone')) => Error: Cannot fetch position of an unrealized block\\n```\"},\"pos_offset\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"direction\"},{\"name\":\"amount\"}]}],\"docs\":\"Returns a coords triple that is offset in a specified `direction` by `amount` of blocks. The default offset amount is\\n1 block. To offset into opposite facing, use negative numbers for the `amount`.\\n\\n```scarpet\\npos_offset(block(0,5,0), 'up', 2)  => [0,7,0]\\npos_offset([0,5,0], 'up', -2 ) => [0,3,0]\\n```\"},\"power\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, returning redstone power level at position.\"},\"print\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]},{\"params\":[{\"name\":\"player\"},{\"name\":\"expr\"}]}],\"docs\":\"prints the value of the expression to chat. Passes the result of the argument to the output unchanged,\\nso `print`-statements can be weaved in code to debug programming issues. By default it uses the same communication\\nchannels that most vanilla commands are using.\\n\\nIn case player is directly specified, it only sends the message to that player, like `tell` command.\\n\\n```scarpet\\nprint('foo') => results in foo, prints: foo\\na = 1; print(a = 5) => results in 5, prints: 5\\na = 1; print(a) = 5 => results in 5, prints: 1\\nprint('pi = '+pi) => prints: pi = 3.141592653589793\\nprint(str('pi = %.2f',pi)) => prints: pi = 3.14\\n```\"},\"property\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"name\"}]}],\"docs\":\"Deprecated by `block_state(pos, name)`\"},\"random_tick\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Causes a random tick at position.\"},\"recipe_data\":{\"signatures\":[{\"params\":[{\"name\":\"item\"},{\"name\":\"type\"}]}],\"docs\":\", `recipe_data(recipe, type?)`\\n\\nreturns all recipes matching either an `item`, or represent actual `recipe` name. In vanilla datapack, for all items\\nthat have one recipe available, the recipe name is the same as the item name but if an item has multiple recipes, its\\ndirect name can be different.\\n\\nRecipe type can take one of the following options:\\n * `'crafting'` - default, crafting table recipe\\n * `'smelting'` - furnace recipe\\n * `'blasting'` - blast furnace recipe\\n * `'smoking'` - smoker recipe\\n * `'campfire_cooking'` - campfire recipe\\n * `'stonecutting'` - stonecutter recipe\\n * `'smithing'` - smithing table (1.16+)\\n\\n The return value is a list of available recipes (even if there is only one recipe available). Each recipe contains of\\n an item triple of the crafting result, list of ingredients, each containing a list of possible variants of the\\n ingredients in this slot, as item triples, or `null` if its a shaped recipe and a given slot in the patterns is left\\n empty, and recipe specification as another list. Possible recipe specs is:\\n  * `['shaped', width, height]` - shaped crafting. `width` and `height` can be 1, 2 or 3.\\n  * `['shapeless']` - shapeless crafting\\n  * `['smelting', duration, xp]` - smelting/cooking recipes\\n  * `['cutting']` - stonecutter recipe\\n  * `['special']` - special crafting recipe, typically not present in the crafting menu\\n  * `['custom']` - other recipe types\\n\\nNote that ingredients are specified as tripes, with count and nbt information. Currently all recipes require always one\\nof the ingredients, and for some recipes, even if the nbt data for the ingredient is specified (e.g. `dispenser`), it\\ncan accept items of any tags.\\n\\nAlso note that some recipes leave some products in the crafting window, and these can be determined using\\n `crafting_remaining_item()` function\\n\\n Examples:\\n ```scarpet\\n recipe_data('iron_ingot_from_nuggets')\\n recipe_data('iron_ingot')\\n recipe_data('glass', 'smelting')\\n ```\"},\"rect\":{\"signatures\":[{\"params\":[{\"name\":\"center\"},{\"name\":\"range\"},{\"name\":\"upper_range\"}]}],\"docs\":\"Returns an iterator, just like `range` function that iterates over a rectangular area of blocks. If only center\\npoint is specified, it iterates over 27 blocks (range of 1). If `range` arguments are specified, expands selection by\\nthe respective number of blocks in each direction. If `upper_range` arguments are specified, it uses `range` for\\nnegative offset, and `upper_range` for positive, similar to `scan`.\\n\\nBasically the arguments are the same as the first three arguments of `scan`, except this function returns the list of\\nblocks that `scan` would evaluate over. If you are going to iterate over these blocks, like `for(rect(args), do_something())`,\\nthen `scan(args, do_something())` is an equivalent, yet more compute-friendly alternative, especially for very large areas.\\n\\n`center` can be defined either as three coordinates, a list of three coords, or a block value.\\n`range` and `upper_range` can have the same representations, just if they are block values, it computes the distance to the center\\nas range instead of taking the values as is.`\"},\"reload_chunk\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Sends full chunk data to clients. Useful when lots stuff happened and you want to refresh it on the clients.\"},\"reset_chunk\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\", `reset_chunk(from_pos, to_pos)`, `reset_chunk([pos, ...])`\\nRemoves and resets the chunk, all chunks in the specified area or all chunks in a list at once, removing all previous\\nblocks and entities, and replacing it with a new generation. For all currently loaded chunks, they will be brought\\nto their current generation status, and updated to the player. All chunks that are not in the loaded area, will only\\nbe generated to the `'structure_starts'` status, allowing to generate them fully as players are visiting them.\\nChunks in the area that has not been touched yet by the game will not be generated / regenerated.\\n\\nIt returns a `map` with a report indicating how many chunks were affected, and how long each step took:\\n * `requested_chunks`: total number of chunks in the requested area or list\\n * `affected_chunks`: number of chunks that will be removed / regenerated\\n * `loaded_chunks`: number of currently loaded chunks in the requested area / list\\n * `relight_count`: number of relit chunks\\n * `relight_time`: time took to relit chunks\\n * `layer_count_<status>`: number of chunks for which a `<status>` generation step has been performed\\n * `layer_time_<status>`: cumulative time for all chunks spent on generating `<status>` step\"},\"sample_noise\":{\"signatures\":[{\"params\":[{\"name\":\"\"}]}],\"docs\":\", `sample_noise(pos, ... types?)` 1.18+\\n\\nSamples the world generation noise values / data driven density function(s) at a given position.\\n\\nIf no types are passed in, or no arguments are given, it returns a list of all the available registry defined density functions.\\n\\nWith a single function name passed in, it returns a scalar. With multiple function names passed in, it returns a list of results.\\n\\nFunction accepts any registry defined density functions, both built in, as well as namespaced defined in datapacks.\\nOn top of that, scarpet provides the following list of noises sampled directly from the current level (and not returned with no-argument call):\\n\\n\\n`'barrier_noise'`, `'fluid_level_floodedness_noise'`, `'fluid_level_spread_noise'`, `'lava_noise'`,\\n`'temperature'`, `'vegetation'`, `'continents'`, `'erosion'`, `'depth'`, `'ridges'`,\\n`'initial_density_without_jaggedness'`, `'final_density'`, `'vein_toggle'`, `'vein_ridged'` and `'vein_gap'`\\n\\n```scarpet\\n// requesting single value\\nsample_density(pos, 'continents') => 0.211626790923\\n// passing type as multiple arguments\\nsample_density(pos, 'continents', 'depth', 'overworld/caves/pillars', 'mydatapack:foo/my_function') => [-0.205013844481, 1.04772473438, 0.211626790923, 0.123]\\n```\"},\"scan\":{\"signatures\":[{\"params\":[{\"name\":\"center\"},{\"name\":\"range\"},{\"name\":\"upper_range\"},{\"name\":\"expr\"}]}],\"docs\":\"Evaluates expression over area of blocks defined by its center `center = (cx, cy, cz)`, expanded in all directions\\nby `range = (dx, dy, dz)` blocks, or optionally in negative with `range` coords, and `upper_range` coords in\\npositive values. That means that if you want a box starting at the northwest coord with given base, width and height\\ndimensions, you can do `'scan(center, 0, 0, 0, w, h, d, ...)`.\\n\\n`center` can be defined either as three coordinates, a single tuple of three coords, or a block value.\\n`range` and `upper_range` can have the same representations, just if they are block values, it computes the distance to\\nthe center as range instead of taking the values as is. That way you can iterate from the center to a box whose surface\\narea constains the `range` and/or `upper_range` blocks.\\n\\n`expr` receives `_x, _y, _z` variables as coords of current analyzed block and `_`, which represents the block itself.\\n\\nReturns number of successful evaluations of `expr` (with `true` boolean result) unless called in void context,\\nwhich would cause the expression not be evaluated for their boolean value.\\n\\n`scan` also handles `continue` and `break` statements, using `continue`'s return value to use in place of expression\\nreturn value. `break` return value has no effect.\"},\"see_sky\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, returning true if the block can see sky.\"},\"set\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"block\"},{\"name\":\"property\"},{\"name\":\"value\"},{\"name\":\"\"},{\"name\":\"block_data\"}]}],\"docs\":\", `set(pos, block, [property?, value?, ...], block_data?)`, `set(pos, block, {property? -> value?, ...}, block_data?)`\\n\\nFirst argument for the `set` function is either a coord triple, list of three numbers, or a world localized block value.\\nSecond argument, `block`, is either an existing block value, a result of `block()` function, or a string value indicating the block name\\nwith optional state and block data. It is then followed by an optional\\n`property - value` pairs for extra block state (which can also be provided in a list or a map). Optional `block_data` include the block data to\\nbe set for the target block.\\n\\nIf `block` is specified only by name, then if a\\ndestination block is the same the `set` operation is skipped, otherwise is executed, for other potential extra\\nproperties that the original source block may have contained.\\n\\nThe returned value is either the block state that has been set, or `false` if block setting was skipped, or failed\\n\\nThrows `unknown_block` if provided block to set is not valid\\n\\n```scarpet\\nset(0,5,0,'bedrock')  => bedrock\\nset([0,5,0], 'bedrock')  => bedrock\\nset(block(0,5,0), 'bedrock')  => bedrock\\nscan(0,5,0,0,0,0,set(_,'bedrock'))  => 1\\nset(pos(player()), 'bedrock')  => bedrock\\nset(0,0,0,'bedrock')  => 0   // or 1 in overworlds generated in 1.8 and before\\nscan(0,100,0,20,20,20,set(_,'glass'))\\n    // filling the area with glass\\nscan(0,100,0,20,20,20,set(_,block('glass')))\\n    // little bit faster due to internal caching of block state selectors\\nb = block('glass'); scan(0,100,0,20,20,20,set(_,b))\\n    // yet another option, skips all parsing\\nset(x,y,z,'iron_trapdoor')  // sets bottom iron trapdoor\\n\\nset(x,y,z,'iron_trapdoor[half=top]')  // sets the top trapdoor\\nset(x,y,z,'iron_trapdoor','half','top') // also correct - top trapdoor\\nset(x,y,z,'iron_trapdoor', ['half','top']) // same\\nset(x,y,z,'iron_trapdoor', {'half' -> 'top'}) // same\\nset(x,y,z, block('iron_trapdoor[half=top]')) // also correct, block() provides extra parsing of block state\\n\\nset(x,y,z,'hopper[facing=north]{Items:[{Slot:1b,id:\\\"minecraft:slime_ball\\\",Count:16b}]}') // extra block data\\nset(x,y,z,'hopper', {'facing' -> 'north'}, nbt('{Items:[{Slot:1b,id:\\\"minecraft:slime_ball\\\",Count:16b}]}') ) // same\\n```\"},\"set_biome\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"biome_name\"},{\"name\":\"updatetrue\"}]}],\"docs\":\"Changes the biome at that block position. if update is specified and false, then chunk will not be refreshed\\non the clients. Biome changes can only be sent to clients with the entire data from the chunk.\\n\\nBe aware that depending on the MC version and dimension settings biome can be set either in a 1x1x256\\ncolumn or 4x4x4 hyperblock, so for some versions Y will be ignored and for some precision of biome\\nsetting is less than 1x1x1 block.\\n\\nThrows `unknown_biome` if the `biome_name` doesn't exist.\"},\"set_poi\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"type\"},{\"name\":\"occupancy\"}]}],\"docs\":\"Sets a Point of Interest (POI) of a specified type with optional custom occupancy. By default new POIs are not occupied.\\nIf type is `null`, POI at position is removed. In any case, previous POI is also removed. Available POI types are:\\n\\n*   `'unemployed', 'armorer', 'butcher', 'cartographer', 'cleric', 'farmer', 'fisherman', 'fletcher', 'leatherworker', 'librarian', 'mason', 'nitwit', 'shepherd', 'toolsmith', 'weaponsmith', 'home', 'meeting', 'beehive', 'bee_nest', 'nether_portal'`\\n\\nInterestingly, `unemployed`, and `nitwit` are not used in the game, meaning, they could be used as permanent spatial\\nmarkers for scarpet apps. `meeting` is the only one with increased max occupancy of 32.\\n\\nThrows `unknown_poi` if the provided point of interest doesn't exist\"},\"set_structure\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"structure_name\"},{\"name\":\"set_structurepos\"},{\"name\":\"structure_name\"},{\"name\":\"null\"}]}],\"docs\":\"Creates or removes structure information of a structure associated with a chunk of `pos`. Unlike `plop`, blocks are\\nnot placed in the world, only structure information is set. For the game this is a fully functional structure even\\nif blocks are not set. To remove the structure a given point is in, use `structure_references` to find where current\\nstructure starts.\\n\\nRequires a `Structure Variant` or `Standard Structure` name (see above). If standard name is used, the variant of the\\nstructure may depend on the biome, otherwise the default structure for this type will be generated.\\n\\nThrows `unknown_structure` if structure doesn't exist.\"},\"sky_light\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Numeric function, returning the sky light at position (from sky access).\"},\"solid\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block is solid.\"},\"spawn\":{\"signatures\":[{\"params\":[{\"name\":\"name\"},{\"name\":\"pos\"},{\"name\":\"nbt\"}]}],\"docs\":\"Spawns and places an entity in world, like `/summon` vanilla command. Requires a position to spawn, and optional\\nextra nbt data to merge with the entity. What makes it different from calling `run('summon ...')`, is the fact that\\nyou get the entity back as a return value, which is swell.\"},\"spawn_potential\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Returns spawn potential at a location (1.16+ only)\"},\"stack_limit\":{\"signatures\":[{\"params\":[{\"name\":\"item\"}]}],\"docs\":\"Returns number indicating what is the stack limit for the item. Its typically 1 (non-stackable), 16 (like buckets),\\nor 64 - rest. It is recommended to consult this, as other inventory API functions ignore normal stack limits, and\\nit is up to the programmer to keep it at bay. As of 1.13, game checks for negative numbers and setting an item to\\nnegative is the same as empty.\\n\\nThrows `unknown_item` if item doesn't exist.\\n\\n```scarpet\\nstack_limit('wooden_axe') => 1\\nstack_limit('ender_pearl') => 16\\nstack_limit('stone') => 64\\n```\"},\"structure_eligibility\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"structure\"},{\"name\":\"size_needed\"}]}],\"docs\":\"Checks worldgen eligibility for a structure in a given chunk. Requires a `Structure Variant` name (see above),\\nor `Standard Structure` to check structures of this type.\\nIf no structure is given, or `null`, then it will check\\nfor all structures. If bounding box of the structures is also requested, it will compute size of potential\\nstructures. This function, unlike other in the `structure*` category is not using world data nor accesses chunks\\nmaking it preferred for scoping ungenerated terrain, but it takes some compute resources to calculate the structure.\\n\\nUnlike `'structure'` this will return a tentative structure location. Random factors in world generation may prevent\\nthe actual structure from forming.\\n\\nIf structure is specified, it will return `null` if a chunk is not eligible or invalid, `true` if the structure should appear, or\\na map with two values: `'box'` for a pair of coordinates indicating bounding box of the structure, and `'pieces'` for\\nlist of elements of the structure (as a tuple), with its name, direction, and box coordinates of the piece.\\n\\nIf structure is not specified, or a `Standard Structure` was specified, like `'village'`,it will return a set of structure names that are eligible, or a map with structures\\nas keys, and same type of map values as with a single structure call. An empty set or an empty map would indicate that nothing\\nshould be generated there.\\n\\nThrows `unknown_structure` if structure doesn't exist.\"},\"structure_references\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"structure_referencespos\"},{\"name\":\"structure_name\"}]}],\"docs\":\"Returns structure information that a chunk with a given block position is part of. `structure_references` function\\ncan be called with a block, or a block and a structure name. In the first case it returns a list of structure names\\nthat give chunk belongs to. When called with an extra structure name, returns list of positions pointing to the\\nlowest block position in chunks that hold structure starts for these structures. You can query that chunk structures\\nthen to get its bounding boxes.\\n\\nRequires a `Standard Structure` name (see above).\"},\"structures\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"},{\"name\":\"structurespos\"},{\"name\":\"structure_name\"}]}],\"docs\":\"Returns structure information for a given block position. Note that structure information is the same for all the\\nblocks from the same chunk. `structures` function can be called with a block, or a block and a structure name. In\\nthe first case it returns a map of structures at a given position, keyed by structure name, with values indicating\\nthe bounding box of the structure - a pair of two 3-value coords (see examples). When called with an extra structure\\nname, returns a map with two values, `'box'` for bounding box of the structure, and `'pieces'` for a list of\\ncomponents for that structure, with their name, direction and two sets of coordinates\\nindicating the bounding box of the structure piece. If structure is invalid, its data will be `null`.\\n\\nRequires a `Standard Structure` name (see above).\"},\"suffocates\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block causes suffocation.\"},\"ticks_randomly\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block ticks randomly.\"},\"top\":{\"signatures\":[{\"params\":[{\"name\":\"type\"},{\"name\":\"pos\"}]}],\"docs\":\"Returns the Y value of the topmost block at given x, z coords (y value of a block is not important), according to the\\nheightmap specified by `type`. Valid options are:\\n\\n*   `light`: topmost light blocking block (1.13 only)\\n*   `motion`: topmost motion blocking block\\n*   `terrain`: topmost motion blocking block except leaves\\n*   `ocean_floor`: topmost non-water block\\n*   `surface`: topmost surface block\\n\\n```scarpet\\ntop('motion', x, y, z)  => 63\\ntop('ocean_floor', x, y, z)  => 41\\n```\"},\"transparent\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Boolean function, true if the block is transparent.\"},\"update\":{\"signatures\":[{\"params\":[{\"name\":\"pos\"}]}],\"docs\":\"Causes a block update at position.\"},\"volume\":{\"signatures\":[{\"params\":[{\"name\":\"from_pos\"},{\"name\":\"to_pos\"},{\"name\":\"expr\"}]}],\"docs\":\"Evaluates expression for each block in the area, the same as the `scan` function, but using two opposite corners of\\nthe rectangular cuboid. Any corners can be specified, its like you would do with `/fill` command.\\nYou can use a position or three coordinates to specify, it doesn't matter.\\n\\nFor return value and handling `break` and `continue` statements, see `scan` function above.\"},\"weather\":{\"signatures\":[{\"params\":[{\"name\":\"\"}]}],\"docs\":\",`weather(type)`,`weather(type, ticks)`\\n\\nIf called with no args, returns `'clear'`, `'rain` or `'thunder'` based on the current weather. If thundering, will\\nalways return `'thunder'`, if not will return `'rain'` or `'clear'` based on the current weather.\\n\\nWith one arg, (either `'clear'`, `'rain` or `'thunder'`), returns the number of remaining ticks for that weather type.\\nNB: It can thunder without there being a thunderstorm; there has to be both rain and thunder to form a storm. So if\\nrunning `weather()` returns `'thunder'`, you can use `weather('rain')>0` to see if there's a storm going on.\\n\\nWith two args, sets the weather to the given `type` for `ticks` ticks.\\n\\n## Block and World querying\"},\"without_updates\":{\"signatures\":[{\"params\":[{\"name\":\"expr\"}]}],\"docs\":\"Evaluates subexpression without causing updates when blocks change in the world.\\n\\nFor synchronization sake, as well as from the fact that suppressed update can only happen within a tick,\\nthe call to the `expr` is docked on the main server task.\\n\\nConsider following scenario: We would like to generate a bunch of terrain in a flat world following a perlin noise\\ngenerator. The following code causes a cascading effect as blocks placed on chunk borders will cause other chunks to get\\nloaded to full, thus generated:\\n\\n```scarpet\\n__config() -> {'scope' -> 'global'};\\n__on_chunk_generated(x, z) -> (\\n  scan(x,0,z,0,0,0,15,15,15,\\n    if (perlin(_x/16, _y/8, _z/16) > _y/16,\\n      set(_, 'black_stained_glass');\\n    )\\n  )\\n)\\n```\\n\\nThe following addition resolves this issue, by not allowing block updates past chunk borders:\\n\\n```scarpet\\n__config() -> {'scope' -> 'global'};\\n__on_chunk_generated(x, z) -> (\\n  without_updates(\\n    scan(x,0,z,0,0,0,15,15,15,\\n      if (perlin(_x/16, _y/8, _z/16) > _y/16,\\n        set(_, 'black_stained_glass');\\n      )\\n    )\\n  )\\n)\\n```\"}}");
export const MINECRAFT_EVENTS = JSON.parse("{\"__on_player_attacks_entity\":{\"params\":[{\"name\":\"player\"},{\"name\":\"entity\"}],\"docs\":\"Triggered when a player attacks entity, right before it happens server side.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the player from attacking the entity.\"},\"__on_player_breaks_block\":{\"params\":[{\"name\":\"player\"},{\"name\":\"block\"}],\"docs\":\"Called when player breaks a block, right before any changes to the world are done, but the decision is made to remove the block.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the block from being placed.\"},\"__on_player_changes_dimension\":{\"params\":[{\"name\":\"player\"},{\"name\":\"from_pos\"},{\"name\":\"from_dimension\"},{\"name\":\"to_pos\"},{\"name\":\"to_dimension\"}],\"docs\":\"Called when a player moves from one dimension to another. Event is handled still when the player is in its previous\\ndimension and position.\\n\\n`player_changes_dimension` returns `null` as `to_pos` when player goes back to the overworld from the end\\n, since the respawn location of the player is not controlled by the teleport, or a player can still see the end credits. After\\n the player is eligible to respawn in the overworld, `player_respawns` will be triggered.\"},\"__on_player_chooses_recipe\":{\"params\":[{\"name\":\"player\"},{\"name\":\"recipe\"},{\"name\":\"full_stack\"}],\"docs\":\"Triggered when a player clicks a recipe in the crafting window from the crafting book, after server received\\na client request, but before any items are moved from its inventory to the crafting menu.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the recipe from being moved into the crafting grid.\"},\"__on_player_clicks_block\":{\"params\":[{\"name\":\"player\"},{\"name\":\"block\"},{\"name\":\"face\"}],\"docs\":\"Representing left-click attack on a block, usually signifying start of breaking of a block. Triggers right after the server\\nreceives a client packet, before anything happens on the server side.\\n\\nThis event can be cancelled by returning `'cancel'`, which stops the player from breaking a block.\"},\"__on_player_collides_with_entity\":{\"params\":[{\"name\":\"player\"},{\"name\":\"entity\"}],\"docs\":\"Triggered every time a player - entity collisions are calculated, before effects of collisions are applied in the game.\\nUseful not only when colliding with living entities, but also to intercept items or XP orbs before they have an effect\\non the player.\"},\"__on_player_command\":{\"params\":[{\"name\":\"player\"},{\"name\":\"command\"}],\"docs\":\"Triggered when a player runs a command. Command value is returned without the / in front.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the message from being sent.\"},\"__on_player_connects\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Triggered when the player has successfully logged in and was placed in the game.\"},\"__on_player_deals_damage\":{\"params\":[{\"name\":\"player\"},{\"name\":\"amount\"},{\"name\":\"entity\"}],\"docs\":\"Triggered when a player deals damage to another entity. Its applied in the same moment as `player_takes_damage` if both\\nsides of the event are players, and similar for all other entities, just their absorption is taken twice, just noone ever\\nnotices that Â¯\\\\\\\\\\\\_(ã)\\\\_/Â¯\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the damage from being dealt.\"},\"__on_player_deploys_elytra\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Triggered when a server receives a request to deploy elytra, regardless if the flight was agreed upon server side..\"},\"__on_player_dies\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Triggered when a player dies. Player is already dead, so don't revive them then. Event applied before broadcasting messages\\nabout players death and applying external effects (like mob anger etc).\"},\"__on_player_disconnects\":{\"params\":[{\"name\":\"player\"},{\"name\":\"reason\"}],\"docs\":\"Triggered when a player sends a disconnect package or is forcefully disconnected from the server.\"},\"__on_player_drops_item\":{\"params\":[{\"name\":\"player\"}]},\"__on_player_drops_stack\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Triggered when the game receives the request from a player to drop one item or full stack from its inventory.\\nEvent happens before anything is changed server side.\\n\\nThese events can be cancelled by returning `'cancel'`, which prevents the player dropping the items.\"},\"__on_player_escapes_sleep\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Same as `player_wakes_up` but only triggered when pressing the ESC button. Not sure why Mojang decided to send that event\\ntwice when pressing escape, but might be interesting to be able to detect that.\"},\"__on_player_finishes_using_item\":{\"params\":[{\"name\":\"player\"},{\"name\":\"item_tuple\"},{\"name\":\"hand\"}],\"docs\":\"Player using of an item is done. This is controlled server side and is responsible for such events as finishing\\neating. The event is triggered after confirming that the action is valid, and sending the feedback back\\nto the client, but before triggering it and its effects in game.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the player from finishing using the item.\"},\"__on_player_interacts_with_block\":{\"params\":[{\"name\":\"player\"},{\"name\":\"hand\"},{\"name\":\"block\"},{\"name\":\"face\"},{\"name\":\"hitvec\"}],\"docs\":\"Called when player successfully interacted with a block, which resulted in activation of said block,\\nright after this happened.\"},\"__on_player_interacts_with_entity\":{\"params\":[{\"name\":\"player\"},{\"name\":\"entity\"},{\"name\":\"hand\"}],\"docs\":\"Triggered when player right clicks (interacts) with an entity, even if the entity has no vanilla interaction with the player or\\nthe item they are holding. The event is invoked after receiving a packet from the client, before anything happens server side\\nwith that interaction.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the player interacting with the entity.\"},\"__on_player_jumps\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Triggered when a game receives a jump input from the client, and the player is considered standing on the ground.\"},\"__on_player_message\":{\"params\":[{\"name\":\"player\"},{\"name\":\"message\"}],\"docs\":\"Triggered when a player sends a chat message.\"},\"__on_player_picks_up_item\":{\"params\":[{\"name\":\"player\"},{\"name\":\"item\"}],\"docs\":\"Triggered AFTER a player successfully ingested an item in its inventory. Item represents the total stack of items\\ningested by the player. The exact position of these items is unknown as technically these\\nitems could be spread all across the inventory.\"},\"__on_player_places_block\":{\"params\":[{\"name\":\"player\"},{\"name\":\"item_tuple\"},{\"name\":\"hand\"},{\"name\":\"block\"}],\"docs\":\"Triggered when player places a block, after block is placed in the world, but before scoreboard is triggered or player inventory\\nadjusted.\"},\"__on_player_placing_block\":{\"params\":[{\"name\":\"player\"},{\"name\":\"item_tuple\"},{\"name\":\"hand\"},{\"name\":\"block\"}],\"docs\":\"Triggered when player places a block, before block is placed in the world.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the block from being placed.\"},\"__on_player_releases_item\":{\"params\":[{\"name\":\"player\"},{\"name\":\"item_tuple\"},{\"name\":\"hand\"}],\"docs\":\"Player stops right-click-holding on an item that can be held. This event is a result of a client request.\\nExample events that may cause it to happen is releasing a bow. The event is triggered after the game processes\\nthe request, however the `item_tuple` is provided representing the item that the player started with. You can use that and\\ncompare with the currently held item for a delta.\"},\"__on_player_respawns\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Triggered when a player respawns. This includes spawning after death, or landing in the overworld after leaving the end.\\nWhen the event is handled, a player is still in its previous location and dimension - will be repositioned right after. In\\ncase player died, its previous inventory as already been scattered, and its current inventory will not be copied to the respawned\\nentity, so any manipulation to player data is\\nbest to be scheduled at the end of the tick, but you can still use its current reference to query its status as of the respawn event.\"},\"__on_player_rides\":{\"params\":[{\"name\":\"player\"},{\"name\":\"forward\"},{\"name\":\"strafe\"},{\"name\":\"jumping\"},{\"name\":\"sneaking\"}],\"docs\":\"Triggers when a server receives movement controls when riding vehicles. Its handled before the effects are applied\\nserver side.\"},\"__on_player_right_clicks_block\":{\"params\":[{\"name\":\"player\"},{\"name\":\"item_tuple\"},{\"name\":\"hand\"},{\"name\":\"block\"},{\"name\":\"face\"},{\"name\":\"hitvec\"}],\"docs\":\"Called when player right clicks on a block with anything, or interacts with a block. This event is triggered right\\nbefore other interaction events, like `'player_interacts_with_block'` or `'player_places_block'`.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the player interaction.\"},\"__on_player_starts_sneaking\":{\"params\":[{\"name\":\"player\"}]},\"__on_player_starts_sprinting\":{\"params\":[{\"name\":\"player\"}]},\"__on_player_stops_sneaking\":{\"params\":[{\"name\":\"player\"}]},\"__on_player_stops_sprinting\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Four events triggered when player controls for sneaking and sprinting toggle.\"},\"__on_player_swaps_hands\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Triggered when a player sends a command to swap their offhand item. Executed before the effect is applied on the server.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the hands from being swapped.\"},\"__on_player_swings_hand\":{\"params\":[{\"name\":\"player\"},{\"name\":\"hand\"}],\"docs\":\"Triggered when a player starts swinging their hand. The event typically triggers after a corresponding event that caused it\\n(`player_uses_item`, `player_breaks_block`, etc.), but it triggers also after some failed events, like attacking the air. When\\nswinging continues as an effect of an action, no new swinging events will be issued until the swinging is stopped.\"},\"__on_player_switches_slot\":{\"params\":[{\"name\":\"player\"},{\"name\":\"from\"},{\"name\":\"to\"}],\"docs\":\"Triggered when a player changes their selected hotbar slot. Applied right after the server receives the message to switch\\nthe slot.\"},\"__on_player_takes_damage\":{\"params\":[{\"name\":\"player\"},{\"name\":\"amount\"},{\"name\":\"source\"},{\"name\":\"source_entity\"}],\"docs\":\"Triggered when a player is taking damage. Event is executed right after potential absorption was applied and before\\nthe actual damage is applied to the player.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the player from taking damage.\"},\"__on_player_trades\":{\"params\":[{\"name\":\"player\"},{\"name\":\"entity\"},{\"name\":\"buy_left\"},{\"name\":\"buy_right\"},{\"name\":\"sell\"}],\"docs\":\"Triggered when player trades with a merchant. The event is invoked after the server allow the trade, but before the inventory\\nchanges and merchant updates its trade-uses counter.\\nThe parameter `entity` can be `null` if the merchant is not an entity.\"},\"__on_player_uses_item\":{\"params\":[{\"name\":\"player\"},{\"name\":\"item_tuple\"},{\"name\":\"hand\"}],\"docs\":\"Triggers with a right click action. Event is triggered right after a server receives the packet, before the\\ngame manages to do anything about it. Event triggers when player starts eating food, or starts drawing a bow.\\nUse `player_finishes_using_item`, or `player_releases_item` to capture the end of these events.\\n\\nThis event can be cancelled by returning `'cancel'`, which prevents the item from being used.\\n\\nEvent is not triggered when a player places a block, for that use\\n`player_right_clicks_block` or `player_places_block` event.\"},\"__on_player_wakes_up\":{\"params\":[{\"name\":\"player\"}],\"docs\":\"Player wakes up from the bed mid sleep, but not when it is kicked out of bed because it finished sleeping.\"},\"__on_statistic\":{\"params\":[{\"name\":\"player\"},{\"name\":\"category\"},{\"name\":\"event\"},{\"name\":\"value\"}],\"docs\":\"Triggered when a player statistic changes. Doesn't notify on periodic an rhythmic events, i.e.\\n`time_since_death`, `time_since_rest`, and `played_one_minute` since these are triggered every tick. Event\\nis handled before scoreboard values for these statistics are changed.\"}}");
